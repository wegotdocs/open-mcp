import { z } from "zod"

export const inputParamsSchema = {
  "productId": z.number().int().describe("ID of parent product for variation to create"),
  "id": z.number().int().describe("Unique identifier for the resource. read-only").optional(),
  "date_created": z.string().datetime({ offset: true }).describe("The date the variation  was created, in the site's timezone. read-only").optional(),
  "date_created_gmt": z.string().datetime({ offset: true }).describe("The date the variation  was created, as GMT. read-only").optional(),
  "date_modified": z.string().datetime({ offset: true }).describe("The date the variation  was last modified, in the site's timezone. read-only").optional(),
  "date_modified_gmt": z.string().datetime({ offset: true }).describe("The date the variation  was last modified, as GMT. read-only").optional(),
  "description": z.string().describe("Variation description.").optional(),
  "permalink": z.string().describe("Variation URL. read-only").optional(),
  "sku": z.string().describe("Unique identifier.").optional(),
  "price": z.string().describe("Current variation price. read-only").optional(),
  "regular_price": z.string().describe("Variation product price.").optional(),
  "sale_price": z.string().describe("Variation sale price.").optional(),
  "date_on_sale_from": z.string().datetime({ offset: true }).describe("Start date of sale price, in the site's timezone.").optional(),
  "date_on_sale_from_gmt": z.string().datetime({ offset: true }).describe("Start date of sale price, as GMT.").optional(),
  "date_on_sale_to": z.string().datetime({ offset: true }).describe("End date of sale price, in the site's timezone.").optional(),
  "date_on_sale_to_gmt": z.string().datetime({ offset: true }).describe("End date of sale price, as GMT.").optional(),
  "on_sale": z.boolean().describe("Shows if the variation is on sale. read-only").optional(),
  "status": z.string().describe("Variation status. Options: draft, pending, private and publish. Default is publish.").optional(),
  "purchasable": z.boolean().describe("Shows if the variation can be bought. read-only").optional(),
  "virtual": z.boolean().describe("If the variation is virtual. Default is false.").optional(),
  "downloadable": z.boolean().describe("If the variation is downloadable. Default is false.").optional(),
  "downloads": z.array(z.object({ "id": z.string().describe("File ID.").optional(), "name": z.string().describe("File name.").optional(), "file": z.string().describe("File URL.").optional() })).describe("List of downloadable files.").optional(),
  "download_limit": z.number().int().describe("Number of times downloadable files can be downloaded after purchase. Default is -1.").optional(),
  "download_expiry": z.number().int().describe("Number of days until access to downloadable files expires. Default is -1.").optional(),
  "tax_status": z.string().describe("Tax status. Options: taxable, shipping and none. Default is taxable.").optional(),
  "tax_class": z.string().describe("Tax class.").optional(),
  "manage_stock": z.boolean().describe("Stock management at variation level. Default is false.").optional(),
  "stock_quantity": z.number().int().describe("Stock quantity.").optional(),
  "stock_status": z.string().describe("Controls the stock status of the product. Options: instock, outofstock, onbackorder. Default is instock.").optional(),
  "backorders": z.string().describe("If managing stock, this controls if backorders are allowed. Options: no, notify and yes. Default is no.").optional(),
  "backorders_allowed": z.boolean().describe("Shows if backorders are allowed. read-only").optional(),
  "backordered": z.boolean().describe("Shows if the variation is on backordered. read-only").optional(),
  "weight": z.string().describe("Variation weight.").optional(),
  "dimensions": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `dimensions` to the tool, first call the tool `expandSchema` with \"/properties/dimensions\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>").optional(),
  "shipping_class": z.string().describe("Shipping class slug.").optional(),
  "shipping_class_id": z.number().int().describe("Shipping class ID.").optional(),
  "image": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `image` to the tool, first call the tool `expandSchema` with \"/properties/image\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>").optional(),
  "attributes": z.array(z.object({ "id": z.number().int().describe("Attribute ID.").optional(), "name": z.string().describe("Attribute name.").optional(), "option": z.string().describe("Selected attribute term name. Applicable only for Product represents SKU (variation)").optional() })).describe("List of attributes.").optional(),
  "menu_order": z.number().int().describe("Menu order, used to custom sort products.").optional(),
  "meta_data": z.array(z.object({ "id": z.number().int().describe("Meta ID.").optional(), "key": z.string().describe("Meta key.").optional(), "value": z.object({}).describe("Meta value.").optional(), "display_key": z.string().describe("Meta key for UI display.").optional(), "display_value": z.object({}).describe("Meta value for UI display.").optional() })).describe("Meta data properties.").optional()
}