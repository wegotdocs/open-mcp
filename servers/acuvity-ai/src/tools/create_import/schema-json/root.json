{
  "type": "object",
  "properties": {
    "delete": {
      "description": "If set, delete the current imported data.",
      "type": "boolean"
    },
    "AIDomains": {
      "description": "AI domains to import.",
      "items": {
        "description": "AI domain provides an AI risk score given a domain url.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "compliances": {
            "description": "The list of compliance provided by the domain.",
            "example": [
              "SOC2",
              "GDPR",
              "HIPAA"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "dataResidency": {
            "description": "The user data storage location.",
            "example": [
              "US",
              "EU",
              "China"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "dataSharing": {
            "description": "Does the provider share user data with 3rd party or services.",
            "type": "boolean"
          },
          "dataSharingConsent": {
            "description": "Does the provider share user data with consent with 3rd party or services.",
            "type": "boolean"
          },
          "description": {
            "description": "A brief description about the AI domain and what services it provides.",
            "example": "A description text",
            "type": "string"
          },
          "domain": {
            "description": "The domain of the AI provider.",
            "example": "openai.com",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "isAIDomain": {
            "description": "Flag to say if the domain is a AI domain or not.",
            "type": "boolean"
          },
          "models": {
            "description": "List of AI models used by the domain.",
            "example": [
              "gpt-4o",
              "gpt-4"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "providerName": {
            "description": "The name of the main provider.",
            "example": "chatgpt",
            "type": "string"
          },
          "providerRetentionPolicies": {
            "description": "The data retention policies by the domain for each type of users.",
            "items": {
              "description": "Represents data retention policy for a given subscription type.",
              "properties": {
                "description": {
                  "description": "Description of the data retention policy for the subscription type.",
                  "type": "string"
                },
                "duration": {
                  "description": "The duration of time the data retention policy applies to the subscription type.",
                  "type": "string"
                },
                "subscriptionType": {
                  "default": "Free",
                  "description": "The type of subscription for which the data retention policy needs to be\ndefined.",
                  "enum": [
                    "Enterprise",
                    "Paid",
                    "Free"
                  ],
                  "example": "Free"
                }
              },
              "type": "object"
            },
            "type": "array"
          },
          "providerTrainingPolicies": {
            "description": "Does the provider use user data for training its model.",
            "example": [
              {
                "description": "provider uses user data for training the models on Free plan ",
                "subscriptiontype": "Free",
                "useData": true
              }
            ],
            "items": {
              "description": "Represents provider data usage policy for a given subscription type.",
              "properties": {
                "description": {
                  "description": "Description of the data usage policy for a subscription type.",
                  "type": "string"
                },
                "subscriptionType": {
                  "default": "Free",
                  "description": "The type of subscription for which the data retention policy needs to be\ndefined.",
                  "enum": [
                    "Enterprise",
                    "Paid",
                    "Free"
                  ],
                  "example": "Free"
                },
                "useData": {
                  "description": "User Data usage to train or improve the models based on the subscription type.",
                  "type": "boolean"
                }
              },
              "type": "object"
            },
            "type": "array"
          },
          "riskExplanation": {
            "description": "A Markdown formatted string explaining the risk score.",
            "example": "A markdown string",
            "type": "string"
          },
          "riskScore": {
            "description": "The risk score for the domain.",
            "example": 0.5,
            "type": "number"
          },
          "thirdPartyModelUsage": {
            "description": "Does provider use third party model.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "domain",
          "riskScore"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "APIAuthorizations": {
      "description": "APIAuthorizations to import.",
      "items": {
        "description": "Define API Authorizations to define who can access the Acuvity console.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the authorization rule.",
            "type": "string"
          },
          "disabled": {
            "description": "When disabled, an API Authorization has no effect.",
            "type": "boolean"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The name of the authorization rule.",
            "example": "my api authorization.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "permissions": {
            "description": "The individual permissions. Only works if role is Custom.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "role": {
            "default": "Employee",
            "description": "The role for the subjects.",
            "enum": [
              "Administrator",
              "Application",
              "Custom",
              "Employee",
              "Owner",
              "Proxy",
              "Trial",
              "Viewer"
            ]
          },
          "subject": {
            "description": "A tag expression that identifies the authorized user(s).",
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "targetNamespaces": {
            "description": "Defines the namespace or namespaces in which the permission for subject should\napply. If empty, the object's namespace will be used.",
            "example": "/my/namespace",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "PACConfigs": {
      "description": "PACConfigs to import.",
      "items": {
        "description": "PAC Config allows to create a custom PAC, with a selection of services enabled.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "Name of the PAC config. A special name is 'default'. The default pac will be the\none that APEX returns if nothing else is configured.",
            "example": "production",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "providers": {
            "description": "The list of providers to activate for that PAC config.",
            "example": [
              "chatgpt",
              "microsoft-copilot"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name",
          "providers"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "accessPolicies": {
      "description": "Access policies to import.",
      "items": {
        "description": "Define which teams or individuals can access a provider.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "accessDeniedMessage": {
            "description": "The message that is sent if the access is denied.",
            "example": "You must use the company workspace",
            "type": "string"
          },
          "action": {
            "default": "Allow",
            "description": "Define if the provider is allowed or denied for the match expression.",
            "enum": [
              "Allow",
              "Deny"
            ]
          },
          "alertDefinition": {
            "description": "The definition to use for alerting when action is deny.",
            "type": "string"
          },
          "contentPolicies": {
            "description": "The list of content policies to apply when the user has access to the provider.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the access policy.",
            "type": "string"
          },
          "disabled": {
            "description": "If true, the policy is disabled.",
            "type": "boolean"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "match": {
            "description": "The match criteria used to take a decision on the access.",
            "example": "[\n  {\n    \"key\": \"Team\"\n    \"operator\": \"Any\"\n    \"values\": [\"engineers\"]\n  }\n]",
            "items": {
              "description": "Represents a Predicate.",
              "properties": {
                "key": {
                  "description": "The key of the predicate.",
                  "enum": [
                    "Categories",
                    "Confidentiality",
                    "CustomDataTypes",
                    "DstApp",
                    "DstComponent",
                    "DstIPRange",
                    "Exploits",
                    "IsIngress",
                    "Keywords",
                    "Languages",
                    "Malcontents",
                    "Modality",
                    "Model",
                    "PIIs",
                    "Plugin",
                    "Provider",
                    "Relevance",
                    "RiskScore",
                    "Secrets",
                    "Size",
                    "SrcApp",
                    "SrcComponent",
                    "SrcIPRange",
                    "Status",
                    "Team",
                    "Tools",
                    "Topics",
                    "Workspace"
                  ],
                  "example": "Provider"
                },
                "operator": {
                  "description": "The operator of the predicate.",
                  "enum": [
                    "All",
                    "Any",
                    "Empty",
                    "Equals",
                    "EqualsOrGreaterThan",
                    "EqualsOrLesserThan",
                    "NotAny",
                    "NotEmpty",
                    "NotEquals"
                  ],
                  "example": "Equals"
                },
                "values": {
                  "description": "The values of the predicate.",
                  "example": "xxx-xxx-xxx-xxx",
                  "items": {
                    "type": "any"
                  },
                  "type": "array"
                }
              },
              "required": [
                "key",
                "operator"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "minimalLogging": {
            "description": "If true, the system will not log the messages that are not considered as\nviolations.",
            "type": "boolean"
          },
          "name": {
            "description": "The name of the access policy.",
            "example": "my access policy",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "offbandAnalysis": {
            "description": "If true, the system will run analysis in parallel of the user request. When this\nis active, no further policing will be done, and no content policy will run.\nThis can be used to observe the transmitted data and have analysis report,\nwithout adding latency to the end user request, at the price of not being able\nto do any form of content moderation.",
            "type": "boolean"
          },
          "permissive": {
            "description": "If set, just log the decision, but don't enforce it.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "agentConfigs": {
      "description": "Agent configurations to import.",
      "items": {
        "description": "AgentConfig stores the configuration information for the acushield agent.",
        "properties": {
          "DNSMonitorEnabled": {
            "description": "If enabled, the agent will monitor DNS traffic.",
            "type": "boolean"
          },
          "DNSMonitorPolicy": {
            "default": "Warn",
            "description": "What action to take if the DNS monitor cannot start when enabled. Enforce will\nstop the agent with an error, while Warn will post a log and continue on.",
            "enum": [
              "Warn",
              "Enforce"
            ]
          },
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "allowedPauseInterval": {
            "default": "0s",
            "description": "An administrator can set this for users to pause enforcement for this interval.\nA value of 0s means that users are not allowed to pause the enforcement.",
            "example": "60m",
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the agent configuration.",
            "type": "string"
          },
          "disableManagedCA": {
            "description": "If disabled, the agent will rely on the CA already installed and trusted on the\nsystem.",
            "type": "boolean"
          },
          "disableSystemProxyManagement": {
            "description": "If disabled, the system proxy needs to be configured manually.",
            "type": "boolean"
          },
          "disableURLDiscovery": {
            "description": "If disabled, the agent will stop reporting the visited domains.",
            "type": "boolean"
          },
          "enablePause": {
            "description": "If enabled, the agent will have the ability to pause enforcement.",
            "type": "boolean"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "listeningPort": {
            "default": "8081",
            "description": "The port use by the agent to proxy the traffic.",
            "type": "string"
          },
          "name": {
            "description": "The name of the agent configuration.",
            "example": "default",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "pacName": {
            "description": "The name of the PAC configuration to use.",
            "example": "default",
            "type": "string"
          },
          "pingInterval": {
            "default": "10m",
            "description": "The ping interval at which acushield should check in with the backend.",
            "example": "30m",
            "type": "string"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "useDynamicPort": {
            "description": "If system proxy management is enabled and this flag is enabled, the system\ncan take another port, different that the listeningPort.",
            "type": "boolean"
          }
        },
        "required": [
          "listeningPort",
          "name"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "alertDefinitions": {
      "description": "Alert definitions to import.",
      "items": {
        "description": "Represents a definition of an alert.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "cooldown": {
            "default": "5m",
            "description": "If set, how long until a subsequent alert notification can be raised.",
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "The description of the alert definition.",
            "type": "string"
          },
          "friendlyName": {
            "description": "Friendly name of the object.",
            "example": "Simple name",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "message": {
            "description": "The message sent when notifying.",
            "type": "string"
          },
          "name": {
            "description": "The internal reference name of the object. It is a sanitized version of Friendly\nName if empty.",
            "example": "my-simple-policy",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "severity": {
            "default": "Warning",
            "description": "The severity of the alert event.",
            "enum": [
              "Critical",
              "Warning",
              "Info"
            ]
          },
          "sinks": {
            "description": "The sinks used to notify.",
            "example": [
              "Email Notification",
              "Slack Notification"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "trigger": {
            "description": "Represents the criteria to trigger an alert notification.",
            "properties": {
              "interval": {
                "default": "24h",
                "description": "What time window to look for an alert event.",
                "type": "string"
              },
              "occurrences": {
                "default": 1,
                "description": "The number of times an alert event is seen to cause a trigger.",
                "type": "integer"
              }
            },
            "required": [
              "interval",
              "occurrences"
            ],
            "type": "object"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "friendlyName",
          "severity"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "apps": {
      "description": "Apps to import.",
      "items": {
        "description": "App allow to define a generic application.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "components": {
            "description": "List of components for the application.",
            "example": {
              "refMode": "pointer"
            },
            "items": {
              "description": "Represents a particular component of the application.",
              "properties": {
                "CAInjectionEnabled": {
                  "description": "EXPERIMENTAL. If egress mode is inline, the Apex will act as a transparent\nproxy. The certificates that will be served by the proxy are generated by the\nApex itself which are issued by a dynamic TLS CA. If you enable this feature,\nthe matching app component instances will get the CA certificate dynamically\ninjected into the system trust store.",
                  "type": "boolean"
                },
                "description": {
                  "description": "The description of the component.",
                  "example": "The email agent with reading capabilities.",
                  "type": "string"
                },
                "egressMode": {
                  "default": "Disabled",
                  "description": "The egress datapath mode to use for network traffic going out to providers for\nthis application component. By default this is set to disabled. However, this\ncan be changed to mirror traffic where the Apex is only providing visibility\nwith no possibility of any access or content policies to take effect. Or this\ncan be set to inline in which case all traffic to providers will be redirected\nto the Apex which acts as a transparent proxy in this case. In this mode access\nand content policies will take effect.",
                  "enum": [
                    "Disabled",
                    "Mirror",
                    "Inline"
                  ],
                  "example": "Inline"
                },
                "ingressProviderConfigs": {
                  "description": "The ingress provider configurations to serve for this application. If this app\ncomponent serves multiple ingress providers, you must define an ingress provider\nconfig for every single one of them. If you need access to the same ingress\nprovider over different port configurations (for example one serving https while\nanother port serves plain http), then you must define two ingress provider\nconfigurations and reuse the same provider name within the configuration.",
                  "items": {
                    "description": "Represents the configuration if an apex is to act as an ingress for a provider.",
                    "properties": {
                      "dialTLS": {
                        "default": "Preserve",
                        "description": "This option controls the dialing behaviour of the apex to the origin server.\nShould be explicitly set to enabled if the origin expects TLS connections. And\nvice versa it should be set to disabled if the origin expects connections in\nplaintext. By default this setting is set to preserve which means that the apex\nis going to dial using whatever mode it terminated its own connection with: if\nthe apex received a TLS connection, it will dial TLS, if it received a plaintext\nconnection, then it will dial plaintext. The apex receiving behaviour can be\ncontrolled with the listenTLS option. As a last resort this setting can be set\nto auto which means that the apex is going to probe the origin server to\ndetermine if it needs to dial using TLS or not. Note that this is potentially\nsending a TLS Client Hello to a plaintext HTTP server which is not expecting\nthat. Therefore, this option is not recommended if it can be avoided. This\nsetting is ignored in mirror mode.",
                        "enum": [
                          "Preserve",
                          "Auto",
                          "Enabled",
                          "Disabled"
                        ],
                        "example": "Enabled"
                      },
                      "listenPort": {
                        "description": "The listening port. For appcomponent configurations this is the listening port\nthat traffic will be intercepted on or mirrored from.",
                        "example": 8443,
                        "type": "integer"
                      },
                      "listenTLS": {
                        "default": "Auto",
                        "description": "This option controls the receiving behaviour of connection to the apex before\nthey are going to be proxied to the origin server. To control the dialing\nbehaviour of the apex towards the origin server use the dialTLS option. Should\nbe explicitly set to enabled if the listener expects TLS connections. And vice\nversa it should be set to disabled if the listener expects connections in\nplaintext. By default this setting is set to auto which means that the listener\nwill automatically determine if incoming connections are TLS or not: TLS\nconnections will be accepted, as well as  plain TCP connections will be\naccepted, both on the configured listenPort. This setting is ignored in mirror\nmode.",
                        "enum": [
                          "Auto",
                          "Enabled",
                          "Disabled"
                        ],
                        "example": "Enabled"
                      },
                      "listenTLSCert": {
                        "description": "Optional PEM encoded X509v3 certificate to use for the listener for this\nprovider. This setting will be ignored if listenMode is not TLS or Auto or mode\nis not Inline. However, this setting is required if listenTLSKey is set.",
                        "example": "-----BEGIN CERTIFICATE-----\nMIIF...\n...\n-----END CERTIFICATE-----",
                        "type": "string"
                      },
                      "listenTLSKey": {
                        "description": "Optional PEM encoded key pair to use for the listener for this provider. This\nsetting will be ignored if listenMode is not TLS or Auto or mode is not Inline.\nHowever, this setting is required if listenTLSCert is set.",
                        "example": "-----BEGIN EC PRIVATE KEY-----\nMHcCA...\n...\n-----END EC PRIVATE KEY-----",
                        "type": "string"
                      },
                      "mode": {
                        "default": "Disabled",
                        "description": "The ingress datapath mode to use for network traffic arriving for this ingress\nprovider for this application component. By default this is set to disabled.\nHowever, this can be changed to mirror traffic where the Apex is only providing\nvisibility with no possibility of any access or content policies to take effect.\nOr this can be set to inline in which case all traffic to providers will be\nredirected to the Apex which acts as a transparent proxy in this case. In this\nmode access and content policies will take effect.",
                        "enum": [
                          "Disabled",
                          "Mirror",
                          "Inline"
                        ],
                        "example": "Inline"
                      }
                    },
                    "required": [
                      "listenPort"
                    ],
                    "type": "object"
                  },
                  "type": "array"
                },
                "name": {
                  "description": "The component name.",
                  "example": "mailerd",
                  "type": "string"
                },
                "providerName": {
                  "description": "If given, this is the provider name that this component represents. This\n**MUST** match the name of a provider.",
                  "example": "my-app-provider",
                  "type": "string"
                },
                "selector": {
                  "description": "A tag expression that identify an application component based on downstream\nlabels.",
                  "example": [
                    [
                      "component=frontend"
                    ]
                  ],
                  "items": {
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "type": "array"
                },
                "token": {
                  "description": "The token for the current component. Only populated by the backend when the\ncaller's\nclaim match the parents app.subject.",
                  "readOnly": true,
                  "type": "string"
                }
              },
              "required": [
                "name"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "The description of the App.",
            "example": "My Wordpress Instance",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The name of the App.",
            "example": "wordpress",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "selector": {
            "description": "A tag expression that identify an application based on downstream labels.",
            "example": [
              [
                "k8s-namespace=wordpress",
                "zone=us-west"
              ]
            ],
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "subject": {
            "description": "Only bearers with claims matching the subject will be allowed to access the\nappcomponent tokens.",
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "contentPolicies": {
      "description": "Content policies to import.",
      "items": {
        "description": "The policy that decides how to handle the request content.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the content policy.",
            "type": "string"
          },
          "friendlyName": {
            "description": "Friendly name of the object.",
            "example": "Simple name",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "moderations": {
            "description": "The list of moderations to take when the user has access to the provider.",
            "example": "You must use the company workspace",
            "items": {
              "description": "Represents a moderation to take in the content policy.",
              "properties": {
                "action": {
                  "description": "The actual action to take when triggered.",
                  "enum": [
                    "Warn",
                    "Block",
                    "None"
                  ],
                  "example": "Warn"
                },
                "alertDefinition": {
                  "description": "The definition to use for alerting.",
                  "type": "string"
                },
                "link": {
                  "description": "Sets an optional link to reference a document with more explanation on the\nmoderation.",
                  "example": "https://acme.com/policy/aiusage",
                  "type": "string"
                },
                "message": {
                  "description": "The message if the moderation action is warn or block.",
                  "example": "This is not safe for work place (NSFW)",
                  "type": "string"
                },
                "predicates": {
                  "description": "The predicate expression for the moderation to be triggered.",
                  "items": {
                    "description": "Represents a Predicate.",
                    "properties": {
                      "key": {
                        "description": "The key of the predicate.",
                        "enum": [
                          "Categories",
                          "Confidentiality",
                          "CustomDataTypes",
                          "DstApp",
                          "DstComponent",
                          "DstIPRange",
                          "Exploits",
                          "IsIngress",
                          "Keywords",
                          "Languages",
                          "Malcontents",
                          "Modality",
                          "Model",
                          "PIIs",
                          "Plugin",
                          "Provider",
                          "Relevance",
                          "RiskScore",
                          "Secrets",
                          "Size",
                          "SrcApp",
                          "SrcComponent",
                          "SrcIPRange",
                          "Status",
                          "Team",
                          "Tools",
                          "Topics",
                          "Workspace"
                        ],
                        "example": "Provider"
                      },
                      "operator": {
                        "description": "The operator of the predicate.",
                        "enum": [
                          "All",
                          "Any",
                          "Empty",
                          "Equals",
                          "EqualsOrGreaterThan",
                          "EqualsOrLesserThan",
                          "NotAny",
                          "NotEmpty",
                          "NotEquals"
                        ],
                        "example": "Equals"
                      },
                      "values": {
                        "description": "The values of the predicate.",
                        "example": "xxx-xxx-xxx-xxx",
                        "items": {
                          "type": "any"
                        },
                        "type": "array"
                      }
                    },
                    "required": [
                      "key",
                      "operator"
                    ],
                    "type": "object"
                  },
                  "type": "array"
                },
                "redact": {
                  "description": "If true, redacts the keywords, PIIs, and/or secrets defined in the predicates.",
                  "type": "boolean"
                }
              },
              "required": [
                "action"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "name": {
            "description": "The internal reference name of the object. It is a sanitized version of Friendly\nName if empty.",
            "example": "my-simple-policy",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "friendlyName"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "customDataSets": {
      "description": "Custom Data Sets to import.",
      "items": {
        "description": "Allows to create a custom data set.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "dataTypes": {
            "description": "A list of all the data types which are associated to this data set.",
            "example": [
              "ssn",
              "person",
              "location"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "description": {
            "description": "Description of the custom data set.",
            "type": "string"
          },
          "friendlyName": {
            "description": "Friendly name of the object.",
            "example": "Simple name",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The internal reference name of the object. It is a sanitized version of Friendly\nName if empty.",
            "example": "my-simple-policy",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "friendlyName"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "customDataTypes": {
      "description": "Custom Data Types to import.",
      "items": {
        "description": "Allows to create custom data detectors.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the custom data type.",
            "type": "string"
          },
          "friendlyName": {
            "description": "Friendly name of the object.",
            "example": "Simple name",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "matches": {
            "description": "A list of RE2 regular expressions used for data detection. Each expression can\ninclude zero or one capturing group. If no capturing group is present, detection\npositions will be determined based on the entire captured portion of the data.\nIf a single capturing group is included, the detection positions will correspond\nto the part defined by that group. However, if more than one capturing group is\nfound, the system will return a validation error. Additionally, extra\nvalidations are performed to ensure that the regular expressions are not overly\ncomplex, preventing any negative impact on detection engine performance.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "name": {
            "description": "The internal reference name of the object. It is a sanitized version of Friendly\nName if empty.",
            "example": "my-simple-policy",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "friendlyName"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "extractors": {
      "description": "Extractors to import.",
      "items": {
        "description": "An extractor allows to create a reusable extractor for providers.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "SSEManagement": {
            "default": "Collect",
            "description": "This property defines how you want the extractor to work with\nserver-side events. With Collect all the events buffer until the server\ncloses the connection and sends the entire data to the lua code\nwhile Stream will collect line by line and will send events line by line.",
            "enum": [
              "Collect",
              "Stream"
            ]
          },
          "analyzers": {
            "description": "The analyzers parameter allows for customizing which analyzers should be used,\noverriding the default selection. Each analyzer entry can optionally include a\nprefix to modify its behavior:\n\n  - No prefix: Runs only the specified analyzers and any dependencies required\nfor deeper analyzis (slower but more acurate).\n  - '+' (enable): Activates an analyzer that is disabled by default.\n  - '-' (disable): Disables an analyzer that is enabled by default.\n  - '@' (direct execution): Runs the analyzer immediately, bypassing the deeper\nanalyzis (faster but less acurate).\n\nAn analyzers entry can be specified using:\n  - The analyzer name (e.g., 'Toxicity detector')\n  - The analyzer ID (e.g., 'en-text-toxicity-detector')\n  - The analyzer group (e.g., 'Detectors')\n  - A detector name (e.g., 'toxic')\n  - A detector label (e.g., 'insult')\n  - A detector group (e.g., 'Malcontents')\n\nIf left empty, all default analyzers will be executed.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "anonymization": {
            "default": "FixedSize",
            "description": "How to anonymize the data. If deanonymize is true, then VariablSize is required.",
            "enum": [
              "FixedSize",
              "VariableSize"
            ]
          },
          "behavior": {
            "default": "Popup",
            "description": "Defines how to handle error in the case of a webpage. If set to Popup, the error\nwill be shown in a popup. If throw, a javascript error will be returned.",
            "enum": [
              "Popup",
              "Throw",
              "Ignore"
            ]
          },
          "block": {
            "default": "Allow",
            "description": "Block the request to the provider if not Allow. If Before, the data will be\nblocked before running any extraction or analyzis. If After block the request\nafter analysizis.",
            "enum": [
              "Allow",
              "Before",
              "After"
            ]
          },
          "cancelBehavior": {
            "default": "Block",
            "description": "The behavior to take when cancel is chosen from the popup.",
            "enum": [
              "Block",
              "SendRedacted"
            ]
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "deanonymize": {
            "description": "If true, deanonymize the redacted data. This has no effects on streaming output.",
            "type": "boolean"
          },
          "description": {
            "description": "The description of the provider.",
            "type": "string"
          },
          "honorPriorDecision": {
            "description": "If true, it will wait on a prior popup and honor its decision. It only has\neffect if there is an existing popup being shown.",
            "type": "boolean"
          },
          "ignore": {
            "description": "If true, the analysis will run, but nothing will be logged.",
            "type": "boolean"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "method": {
            "description": "The method to match.",
            "enum": [
              "Post",
              "Put",
              "Patch",
              "Get",
              "Delete",
              "Options",
              "Head"
            ],
            "example": [
              "Post"
            ]
          },
          "name": {
            "description": "The internal reference name of the object.",
            "example": "my-extractor",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "path": {
            "description": "A regular expression to match a URL path to log.",
            "example": [
              "/api/v1",
              "/v1/*/hello/*"
            ],
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "script": {
            "description": "If not empty, use this lua code to run the extraction.",
            "type": "string"
          },
          "type": {
            "description": "The type of extractor.",
            "enum": [
              "Input",
              "Output"
            ],
            "example": "Input"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "method",
          "name",
          "path",
          "type"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "ignoredDomains": {
      "description": "Ignored domains to import.",
      "items": {
        "description": "Defines an ignored domain to be excluded from investigation.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "domain": {
            "description": "The domain to ignore.",
            "example": "linkedin.com",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "domain"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "label": {
      "description": "Import label that will be used to identify all the resources imported by this\nresource.",
      "example": "my-super-import",
      "type": "string"
    },
    "orgSettings": {
      "description": "OrgSettings to import.",
      "items": {
        "description": "Manage the default settings for the entire organization.",
        "properties": {
          "CA": {
            "description": "The Certificate authority to use to validate user certificates in PEM format.",
            "example": "-----BEGIN CERTIFICATE-----\nMIIBZTCCAQugAwIBAgIRANYvXLTa16Ykvc9hQ4BBLJEwCgYIKoZIzj0EAwIwEjEQ\nMA4GA1UEAxMHQUNNRSBDQTAeFw0yMTExMDEyMzAwMTlaFw0zMTA5MTAyMzAwMTla\nMBIxEDAOBgNVBAMTB0FDTUUgQ0EwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASa\n7wknroxwB1znupZ67NzTG9Kuc+tNRlbI22eTDNMKYpIexzWDOyiQ95N3GQIdmAz5\nwVu9l2V3VuKUpD9mNgkRo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUw\nAwEB/zAdBgNVHQ4EFgQURIT2kL76vMj9A3r9AUnaiHnHf4EwCgYIKoZIzj0EAwID\nSAAwRQIgS4SGaJ/B1Ul88Jal11Q5BwiY9bY2y9w+4xPNBxSyAIcCIQCSWVq+00xS\nbOmROq+EsxO4L/GzJx7MBbeJ6x142VKSBQ==\n-----END CERTIFICATE-----",
            "type": "string"
          },
          "CACommonNames": {
            "description": "The currently used Certificate authorities's Common Name.",
            "items": {
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          },
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "accessPolicy": {
            "description": "The rego policy that decides if the incoming request can access the\nprovider. If this empty, the dynamic policy transpiled from\nAccessPolicies API objects will be used by Apexes. If set however,\neverything computed by API objects are ignored and this becomes the final\npolicy.",
            "type": "string"
          },
          "allowSupportAccess": {
            "description": "When enabled, an API authorization will be created in your\norganization to allow the Support Team to access your organization in\nread-only fashion to help you with any issue you might have.\nDisable it again to remove the permissions.",
            "type": "boolean"
          },
          "askConsent": {
            "description": "Ask the user of web applications for consent before accessing a monitored\nprovider, using an html splash screen the first time they connect. If\nthis is not set, the users of the providers can still figure out the\nprovider is monitored. This is a courtesy and not a security feature.",
            "type": "boolean"
          },
          "assignPolicy": {
            "description": "The rego policy that decides in which team an user should be in. The team\nwill be passed to the accessPolicy. If this empty, the dynamic policy\ntranspiled from AssignPolicies API objects will be used by Apexes. If set\nhowever, everything computed by API objects are ignored and this becomes\nthe final policy.",
            "type": "string"
          },
          "contentPolicy": {
            "description": "The policy that decides how to handle the request content, once access\nhas been granted by accessPolicy and the content analysis was performed.\nIf this empty, the dynamic policy transpiled from AccessPolicies API\nobjects will be used by Apexes. If set however, everything computed by\nAPI objects are ignored and this becomes the final policy.",
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "disableURLDiscovery": {
            "description": "If true, it disables discovering of the visited URLs.",
            "type": "boolean"
          },
          "fingerprints": {
            "description": "the fingerprint of the cas in the chain.",
            "items": {
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "profile": {
            "description": "A few sentences about the organization. The description must be short\nand detailed. It will be used by the inference engine to decide if the content\nsent by the users are relevant to your company.",
            "example": "Acme Corp is a publicly traded company specialized in car manufacturing.",
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "providersWithoutConsent": {
            "description": "The providers which do not request employees' consent.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "safeUsageURL": {
            "description": "A link to the AI Safe Usage Document for the organization. \nIf provided, it is presented in the consent banner to the employees.",
            "type": "string"
          },
          "storeInputFiles": {
            "description": "If set, files uploaded by the users will be stored.",
            "type": "boolean"
          },
          "storeOutputFiles": {
            "description": "If set, files sent to the users will be stored.",
            "type": "boolean"
          },
          "subjectKeyIDs": {
            "description": "the IDs of the subject keys of the cas in the chain.",
            "items": {
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "useRegoCodeOnly": {
            "description": "If true, it uses Rego code to define team assignment, provider access and\ncontent policies.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "type": "array"
    },
    "providerTeams": {
      "description": "Provider teams to import.",
      "items": {
        "description": "Provider Teams can be created to create groups of people, identified by their\njwt claims\nthat can be used when writing Access Policies.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the provider team.",
            "type": "string"
          },
          "disabled": {
            "description": "Set the provider team to be disabled.",
            "type": "boolean"
          },
          "excludedSubject": {
            "description": "A tag expression that identifies user(s) to not include in the team, even if\ntheir claims match the subject.",
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The name of the provider team.",
            "example": "engineers",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "subject": {
            "description": "A tag expression that identifies user(s).",
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "providerTokens": {
      "description": "ProviderTokens to import.",
      "items": {
        "description": "ProviderToken are upstream tokens for the 'Provider' configured on our system to\nbe used by the acuvity proxy.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "Name of the token. As token contents are hidden after creation, name allows a\nway to delete it.",
            "example": "openai-token-1",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "provider": {
            "description": "Name of the provider this token is used with.",
            "example": "openai",
            "type": "string"
          },
          "token": {
            "description": "token to authenticate with the provider.",
            "example": "token1",
            "type": "string"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name",
          "provider",
          "token"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "providers": {
      "description": "Providers to import.",
      "items": {
        "description": "Providers are services that can be accessed using the APEX. These can\nboth be external services as well as internal services built/deployed within the\norganization.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "analyzeOutput": {
            "description": "If enabled, run the analysis pipelines on the provider output. No policy will be\napplied, but the response will be analyzed and classified.",
            "type": "boolean"
          },
          "category": {
            "description": "The category of the provider.",
            "enum": [
              "User",
              "App"
            ],
            "example": "User"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "The description of the provider.",
            "type": "string"
          },
          "errorTransformer": {
            "description": "Used to transform errors before sending them back to the client.",
            "properties": {
              "contentType": {
                "default": "application/json",
                "description": "The Content-Type to use when returning a formatted error.",
                "type": "string"
              },
              "statusCode": {
                "description": "HTTP status code to return, instead of the classical one.",
                "type": "integer"
              },
              "template": {
                "description": "Go template to process and transform the error. The delimiters\nare << and >> to prevent collision with acuctl templating.\nThe template will be passed the following informations:\n\n- `.Messages`: a list of string containing the messages to return.\n- `.Code`: The original status code.\n- `.TransformedCode`: The transformed status code.\n- `.Action`: The policy decision action (ask or deny).\n\nAll the sprig text function are available.",
                "example": "{\"error\": \"<< .Messages | join \", \" >>\" }",
                "type": "string"
              }
            },
            "type": "object"
          },
          "experimental": {
            "description": "If true, consider this provider as experimental. It will require to use a custom\nPAC Config to make it usable from the proxy.pac.",
            "type": "boolean"
          },
          "extractors": {
            "description": "List of extractors for the provider.",
            "items": {
              "description": "This object allows to either define an extractor for the provider, or to\nreference an existing extractor from database.",
              "properties": {
                "def": {
                  "description": "An extractor allows to create a reusable extractor for providers.",
                  "properties": {
                    "ID": {
                      "description": "ID is the identifier of the object.",
                      "readOnly": true,
                      "type": "string"
                    },
                    "SSEManagement": {
                      "default": "Collect",
                      "description": "This property defines how you want the extractor to work with\nserver-side events. With Collect all the events buffer until the server\ncloses the connection and sends the entire data to the lua code\nwhile Stream will collect line by line and will send events line by line.",
                      "enum": [
                        "Collect",
                        "Stream"
                      ]
                    },
                    "analyzers": {
                      "description": "The analyzers parameter allows for customizing which analyzers should be used,\noverriding the default selection. Each analyzer entry can optionally include a\nprefix to modify its behavior:\n\n  - No prefix: Runs only the specified analyzers and any dependencies required\nfor deeper analyzis (slower but more acurate).\n  - '+' (enable): Activates an analyzer that is disabled by default.\n  - '-' (disable): Disables an analyzer that is enabled by default.\n  - '@' (direct execution): Runs the analyzer immediately, bypassing the deeper\nanalyzis (faster but less acurate).\n\nAn analyzers entry can be specified using:\n  - The analyzer name (e.g., 'Toxicity detector')\n  - The analyzer ID (e.g., 'en-text-toxicity-detector')\n  - The analyzer group (e.g., 'Detectors')\n  - A detector name (e.g., 'toxic')\n  - A detector label (e.g., 'insult')\n  - A detector group (e.g., 'Malcontents')\n\nIf left empty, all default analyzers will be executed.",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "anonymization": {
                      "default": "FixedSize",
                      "description": "How to anonymize the data. If deanonymize is true, then VariablSize is required.",
                      "enum": [
                        "FixedSize",
                        "VariableSize"
                      ]
                    },
                    "behavior": {
                      "default": "Popup",
                      "description": "Defines how to handle error in the case of a webpage. If set to Popup, the error\nwill be shown in a popup. If throw, a javascript error will be returned.",
                      "enum": [
                        "Popup",
                        "Throw",
                        "Ignore"
                      ]
                    },
                    "block": {
                      "default": "Allow",
                      "description": "Block the request to the provider if not Allow. If Before, the data will be\nblocked before running any extraction or analyzis. If After block the request\nafter analysizis.",
                      "enum": [
                        "Allow",
                        "Before",
                        "After"
                      ]
                    },
                    "cancelBehavior": {
                      "default": "Block",
                      "description": "The behavior to take when cancel is chosen from the popup.",
                      "enum": [
                        "Block",
                        "SendRedacted"
                      ]
                    },
                    "createTime": {
                      "description": "Creation date of the object.",
                      "format": "date-time",
                      "readOnly": true,
                      "type": "string"
                    },
                    "deanonymize": {
                      "description": "If true, deanonymize the redacted data. This has no effects on streaming output.",
                      "type": "boolean"
                    },
                    "description": {
                      "description": "The description of the provider.",
                      "type": "string"
                    },
                    "honorPriorDecision": {
                      "description": "If true, it will wait on a prior popup and honor its decision. It only has\neffect if there is an existing popup being shown.",
                      "type": "boolean"
                    },
                    "ignore": {
                      "description": "If true, the analysis will run, but nothing will be logged.",
                      "type": "boolean"
                    },
                    "importHash": {
                      "description": "The hash of the structure used to compare with new import version.",
                      "type": "string"
                    },
                    "importLabel": {
                      "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
                      "type": "string"
                    },
                    "method": {
                      "description": "The method to match.",
                      "enum": [
                        "Post",
                        "Put",
                        "Patch",
                        "Get",
                        "Delete",
                        "Options",
                        "Head"
                      ],
                      "example": [
                        "Post"
                      ]
                    },
                    "name": {
                      "description": "The internal reference name of the object.",
                      "example": "my-extractor",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "The namespace of the object.",
                      "readOnly": true,
                      "type": "string"
                    },
                    "path": {
                      "description": "A regular expression to match a URL path to log.",
                      "example": [
                        "/api/v1",
                        "/v1/*/hello/*"
                      ],
                      "type": "string"
                    },
                    "propagate": {
                      "default": true,
                      "description": "Propagates the object to all child namespaces. This is always true.",
                      "type": "boolean"
                    },
                    "script": {
                      "description": "If not empty, use this lua code to run the extraction.",
                      "type": "string"
                    },
                    "type": {
                      "description": "The type of extractor.",
                      "enum": [
                        "Input",
                        "Output"
                      ],
                      "example": "Input"
                    },
                    "updateTime": {
                      "description": "Last update date of the object.",
                      "format": "date-time",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "required": [
                    "method",
                    "name",
                    "path",
                    "type"
                  ],
                  "type": "object"
                },
                "hosts": {
                  "description": "Optional hosts to match. This is useful in case the provider has multiple hosts\nto discriminate which logger to use.",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "ref": {
                  "description": "References a preexisting extractor definition.",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "type": "array"
          },
          "friendlyName": {
            "description": "Friendly Name of the provider.",
            "example": "OpenAI",
            "type": "string"
          },
          "hosts": {
            "description": "Hosts supported by the providers.",
            "items": {
              "description": "This is node definition.",
              "properties": {
                "disableFingerprintingResistance": {
                  "description": "Disable Apex routines to try to mimic client's tls handshake signature. You\nprobably want this on.",
                  "type": "boolean"
                },
                "name": {
                  "description": "The hostname.",
                  "example": "chat.openai.com",
                  "type": "string"
                },
                "prefix": {
                  "description": "URL prefix for additional matching.",
                  "type": "string"
                },
                "proxyLabel": {
                  "description": "The proxy label to use to exit to this host.",
                  "example": "default",
                  "type": "string"
                }
              },
              "required": [
                "name"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "icon": {
            "description": "The icon of the provider, base64 encoded.",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "injectors": {
            "description": "Defines injection point for javascript snippet.",
            "items": {
              "description": "TODO.",
              "properties": {
                "delayXHRPatching": {
                  "description": "Since JS world is the mess we all know, there are some cases when we must delay\nthe monkey patching of the XHR request.",
                  "type": "boolean"
                },
                "hosts": {
                  "description": "Optional hosts to match. This is useful in case the provider has multiple hosts\nto discriminate which logger to use.",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "method": {
                  "description": "The method to match.",
                  "enum": [
                    "Post",
                    "Put",
                    "Patch",
                    "Get",
                    "Delete",
                    "Options",
                    "Head"
                  ],
                  "example": [
                    "Post"
                  ]
                },
                "path": {
                  "description": "A regular expression to match a URL path to log.",
                  "example": [
                    "/api/v1",
                    "/v1/*/hello/*"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "method",
                "path"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "mappers": {
            "description": "List of user mappers.",
            "items": {
              "description": "TODO.",
              "properties": {
                "expiration": {
                  "default": "1h",
                  "description": "Set how long the data should be cached.",
                  "type": "string"
                },
                "hosts": {
                  "description": "Optional hosts to match. This is useful in case the provider has multiple hosts\nto discriminate which logger to use.",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "method": {
                  "description": "The method to match.",
                  "enum": [
                    "Post",
                    "Put",
                    "Patch",
                    "Get",
                    "Delete",
                    "Options",
                    "Head"
                  ],
                  "example": [
                    "Post"
                  ]
                },
                "name": {
                  "description": "The name of the extractor. It will be used to identify which extractor was used\nduring an extraction.",
                  "type": "string"
                },
                "path": {
                  "description": "A regular expression to match a URL path to log.",
                  "example": [
                    "/api/v1",
                    "/v1/*/hello/*"
                  ],
                  "type": "string"
                },
                "script": {
                  "description": "If not empty, use this lua code to run the extraction.",
                  "type": "string"
                }
              },
              "required": [
                "method",
                "path"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "name": {
            "description": "Name of the provider.",
            "example": "openai",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "riskScore": {
            "description": "The latest risk score of the provider.",
            "type": "number"
          },
          "status": {
            "default": "Stable",
            "description": "The support status of the provider.",
            "enum": [
              "Stable",
              "Unstable"
            ]
          },
          "tokenSwap": {
            "description": "If true, consider the incoming calls to use an acuvity token and swap them using\nregistered providertokens.",
            "type": "boolean"
          },
          "trustedCA": {
            "description": "If set, additionally trust the Certificate Authorities from the PEM data. This\nis useful when working on a custom provider using a self signed CA chain.",
            "type": "string"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "upstreamUnsecure": {
            "description": "If enabled, force the ustream scheme to be HTTP instead of https. Mostly use for\ndev purposes.",
            "type": "boolean"
          }
        },
        "required": [
          "category",
          "friendlyName",
          "name",
          "status"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "proxyroundtrips": {
      "description": "Proxy roundtrip to import. This will populate dummy data.",
      "items": {
        "description": "This is a Proxy roundtrip.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "alerts": {
            "description": "List of alerts that got raised during the policy resolution.",
            "items": {
              "description": "Represents an alert event raised by a policy.",
              "properties": {
                "alertDefinition": {
                  "description": "The name of the alert definition that triggered the alert event.",
                  "example": "warning-notification",
                  "type": "string"
                },
                "alertDefinitionNamespace": {
                  "description": "The namespace of the alert definition.",
                  "type": "string"
                },
                "principal": {
                  "description": "Describe the principal.",
                  "properties": {
                    "IP": {
                      "description": "The source IP address of the request.",
                      "example": "192.0.2.42",
                      "type": "string"
                    },
                    "app": {
                      "description": "Describes the principal information of an application.",
                      "properties": {
                        "component": {
                          "description": "The component of the application request.",
                          "example": "frontend",
                          "type": "string"
                        },
                        "labels": {
                          "description": "The list of labels attached to an application request.",
                          "example": [
                            "country=us",
                            "another-label"
                          ],
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "name": {
                          "description": "The name of the application.",
                          "example": "MyApp",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "authType": {
                      "description": "The type of authentication.",
                      "enum": [
                        "Certificate",
                        "UserToken",
                        "AppToken",
                        "Hostname",
                        "Token",
                        "ComponentToken",
                        "External"
                      ]
                    },
                    "claims": {
                      "description": "List of claims extracted from the user query.",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "team": {
                      "description": "The team that was used to authorize the request.",
                      "example": "admins",
                      "type": "string"
                    },
                    "tokenName": {
                      "description": "The name of the token, if any.",
                      "example": "my-user-token",
                      "type": "string"
                    },
                    "type": {
                      "description": "The type of principal.",
                      "enum": [
                        "User",
                        "App",
                        "External"
                      ],
                      "example": [
                        "User"
                      ]
                    },
                    "user": {
                      "description": "Describes the principal information of a user.",
                      "properties": {
                        "name": {
                          "description": "Identification bit that will be used to identify the origin of the request.",
                          "example": "user@company.com",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    }
                  },
                  "required": [
                    "type"
                  ],
                  "type": "object"
                },
                "provider": {
                  "description": "The provider used that the alert came from.",
                  "type": "string"
                },
                "timestamp": {
                  "description": "When the alert event was raised.",
                  "format": "date-time",
                  "readOnly": true,
                  "type": "string"
                }
              },
              "required": [
                "alertDefinition",
                "principal"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "annotations": {
            "description": "Annotations attached to the log.",
            "items": {
              "type": "string"
            },
            "type": "object"
          },
          "client": {
            "description": "The client used to send the request.",
            "example": "curl",
            "type": "string"
          },
          "clientVersion": {
            "description": "The version of the client used to send the request.",
            "example": "7.64.1",
            "type": "string"
          },
          "decision": {
            "description": "Tell what was the decision about the data.",
            "enum": [
              "Deny",
              "Allow",
              "Ask",
              "Bypassed",
              "ForbiddenUser",
              "Skipped"
            ]
          },
          "destination": {
            "description": "Represents the destination that this request was made to.",
            "properties": {
              "app": {
                "description": "The name of the application that the domain belongs to.",
                "example": "MyApp",
                "type": "string"
              },
              "component": {
                "description": "The component of the application that the domain belongs to.",
                "example": "frontend",
                "type": "string"
              },
              "host": {
                "description": "The host name of the request.",
                "example": "api.openai.com",
                "type": "string"
              },
              "ip": {
                "description": "The destination IP address of the request.",
                "example": "192.0.2.42",
                "type": "string"
              },
              "labels": {
                "description": "The list of labels attached to the application request destination.",
                "example": [
                  "country=us",
                  "another-label"
                ],
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "required": [
              "host"
            ],
            "type": "object"
          },
          "extractions": {
            "description": "The extractions to log.",
            "items": {
              "description": "Represents the extracted information to log.",
              "properties": {
                "PIIs": {
                  "description": "The PIIs found during classification.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'PIIs' accross all analyzers.\n\nExample of PIIs detected: aba_routing_number, address, bank_account,\nbitcoin_wallet, credit_card, driver_license, email_address, itin_number,\nlocation, medical_license, money_amount, passport_number, person, phone_number,\nssn.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 < score <0.33\n  - confidence: 'medium', 0.33 <= score < 0.66\n  - confidence: 'high', 0.66 <= score <= 1.",
                  "example": {
                    "ssn": 0.8
                  },
                  "items": {
                    "format": "float",
                    "type": "number"
                  },
                  "type": "object"
                },
                "annotations": {
                  "description": "Annotations attached to the extraction.",
                  "items": {
                    "type": "string"
                  },
                  "type": "object"
                },
                "categories": {
                  "description": "The categories are remapping of the modalities in a more human friendly way.",
                  "items": {
                    "description": "Represents the modality of a some data.",
                    "properties": {
                      "group": {
                        "description": "The group of data.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups in the 'Modality' analyzer group.\n\nExample of group: application, archive, audio, code, document, executable, font,\nimage, text, unknown, video.",
                        "example": "image",
                        "type": "string"
                      },
                      "type": {
                        "description": "The type of data.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector names in the 'Modality' analyzer group.\n\nExample of type: 3dsm, 3gp, 3mf, ace, ada, ai, apk, applebplist, appleplist, ar,\narc, arj, asc, asf, asm, asp, au, autohotkey, autoit, avi, avif, awk, ax, batch,\nbazel, bcad, bib, bmp, bpg, brainfuck, brf, bzip, bzip3, c, cab, cat, cdf, chm,\nclojure, cmake, cobol, coff, coffeescript, com, cpl, cpp, crt, crx, cs, csproj,\ncss, csv, dart, deb, dex, dey, dicom, diff, django, dll, dm, dmg, dmigd,\ndmscript, doc, dockerfile, docx, dotx, dwg, dxf, dylib, elf, elixir, emf, eml,\nepub, erb, erlang, exe, flac, flv, fortran, fpx, gemfile, gemspec, gif,\ngitattributes, gitmodules, gleam, go, gradle, groovy, gzip, h, h5, handlebars,\nhaskell, hcl, heif, hlp, hpp, hta, htaccess, html, hwp, icns, ico, ics,\nignorefile, ini, internetshortcut, ipynb, iso, jar, java, javabytecode,\njavascript, jinja, jng, jnlp, jp2, jpeg, json, jsonl, jsx, julia, jxl, ko,\nkotlin, latex, lha, license, lisp, lnk, lock, lua, lz, lz4, m3u, m4, macho,\nmakefile, markdown, matlab, mht, midi, mkv, mp3, mp4, mpegts, mscompress, msi,\nmsix, mui, mum, npy, npz, objectivec, ocaml, ocx, odex, odin, odp, ods, odt,\nogg, one, onnx, otf, outlook, pascal, pcap, pdb, pdf, pebin, pem, perl, php,\npickle, png, po, postscript, powershell, ppt, pptx, prolog, proteindb, proto,\npsd, python, pythonbytecode, pytorch, qoi, qt, r, randomascii, rar, rdf, rlib,\nrll, rpm, rst, rtf, ruby, rust, scala, scheme, scr, scss, sevenzip, sgml, shell,\nsmali, snap, so, solidity, sql, sqlite, squashfs, srt, stlbinary, stltext, sum,\nsvg, swf, swift, symlinktext, sys, tar, tcl, textproto, tga, thumbsdb, tiff,\ntoml, torrent, tsv, tsx, ttf, twig, txt, txtascii, txtutf16, txtutf8,\ntypescript, vba, vbe, vcxproj, verilog, vhdl, visio, vtt, vue, wad, wasm, wav,\nwebm, webp, webtemplate, winregistry, wma, wmf, wmv, woff, woff2, xar, xcf, xls,\nxlsb, xlsx, xml, xpi, xz, yaml, yara, zig, zip, zlibstream, zst.",
                        "example": "png",
                        "type": "string"
                      }
                    },
                    "required": [
                      "group",
                      "type"
                    ],
                    "type": "object"
                  },
                  "type": "array"
                },
                "confidentiality": {
                  "description": "The level of general confidentiality of the input.",
                  "example": 0.9,
                  "type": "number"
                },
                "customDataSets": {
                  "description": "The custom data sets found during classification.",
                  "example": {
                    "cds": {
                      "ct1": 1,
                      "ct2": 2
                    }
                  },
                  "items": {
                    "items": {
                      "type": "float"
                    },
                    "type": "object"
                  },
                  "type": "object"
                },
                "customDataTypes": {
                  "description": "The custom data types found during classification.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 < score <0.33\n  - confidence: 'medium', 0.33 <= score < 0.66\n  - confidence: 'high', 0.66 <= score <= 1.",
                  "example": {
                    "my_cdt": 1
                  },
                  "items": {
                    "format": "float",
                    "type": "number"
                  },
                  "type": "object"
                },
                "data": {
                  "description": "The data extracted.",
                  "type": "string"
                },
                "detections": {
                  "description": "The textual detections found while applying policies.",
                  "items": {
                    "description": "Represents a textual detection done by policy.",
                    "properties": {
                      "end": {
                        "description": "The end position of the detection in the original data.",
                        "type": "integer"
                      },
                      "key": {
                        "description": "The key that is used in the name's place, If empty, a sequence of X's are used.",
                        "type": "string"
                      },
                      "name": {
                        "description": "The name of the detection.",
                        "type": "string"
                      },
                      "redacted": {
                        "description": "If true this detection has been redacted.",
                        "type": "boolean"
                      },
                      "redactedEnd": {
                        "description": "The end position of the detection in the redacted data.",
                        "type": "integer"
                      },
                      "redactedStart": {
                        "description": "The start position of the detection in the redacted data.",
                        "type": "integer"
                      },
                      "score": {
                        "description": "The confidence score of the detection.",
                        "type": "number"
                      },
                      "start": {
                        "description": "The start position of the detection in the original data.",
                        "type": "integer"
                      },
                      "type": {
                        "description": "The type of detection.",
                        "enum": [
                          "Keyword",
                          "PII",
                          "Secret",
                          "CDT"
                        ]
                      }
                    },
                    "type": "object"
                  },
                  "type": "array"
                },
                "exploits": {
                  "description": "The various exploits attempts.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Exploits' accross all analyzers.\n\nExample of exploits detected: jailbreak, prompt_injection, malicious_url.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 < score <0.33\n  - confidence: 'medium', 0.33 <= score < 0.66\n  - confidence: 'high', 0.66 <= score <= 1.",
                  "example": {
                    "prompt_injection": 0.8
                  },
                  "items": {
                    "format": "float",
                    "type": "number"
                  },
                  "type": "object"
                },
                "hash": {
                  "description": "The hash of the extraction.",
                  "type": "string"
                },
                "intent": {
                  "description": "The estimated intent embodied into the text.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Intent' accross all analyzers.\n\nExample of intent detected: explain, outline, summarize, write.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 < score <0.33\n  - confidence: 'medium', 0.33 <= score < 0.66\n  - confidence: 'high', 0.66 <= score <= 1.",
                  "example": {
                    "write": 0.8
                  },
                  "items": {
                    "format": "float",
                    "type": "number"
                  },
                  "type": "object"
                },
                "internal": {
                  "description": "If true, this extraction is for internal use only. This can be used by agentic\nsystems to mark an extraction as internal only as opposed to user facing.",
                  "type": "boolean"
                },
                "isFile": {
                  "description": "If true, the data of the extraction is a file.",
                  "type": "boolean"
                },
                "isStored": {
                  "description": "If true, indicates that the file has been stored.",
                  "type": "boolean"
                },
                "keywords": {
                  "description": "The keywords found during classification.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 < score <0.33\n  - confidence: 'medium', 0.33 <= score < 0.66\n  - confidence: 'high', 0.66 <= score <= 1.",
                  "example": {
                    "my_keywork": 0.8
                  },
                  "items": {
                    "format": "float",
                    "type": "number"
                  },
                  "type": "object"
                },
                "label": {
                  "description": "A means of distinguishing what was extracted, such as prompt, input file or\ncode.",
                  "type": "string"
                },
                "languages": {
                  "description": "The language of the classification.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Languages' accross all analyzers.\n\nExample of languages: chinese, english, french, german, gibberish, japanese,\nrussian, spanish.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 < score <0.33\n  - confidence: 'medium', 0.33 <= score < 0.66\n  - confidence: 'high', 0.66 <= score <= 1.",
                  "example": {
                    "english": 0.8
                  },
                  "items": {
                    "format": "float",
                    "type": "number"
                  },
                  "type": "object"
                },
                "luaID": {
                  "description": "An internal field for lua code. it is ignored by the API.",
                  "type": "string"
                },
                "malcontents": {
                  "description": "The various malcontents attempts.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Malcontents' accross all analyzers.\n\nExample of malcontents: biased, harmful, toxic.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 < score <0.33\n  - confidence: 'medium', 0.33 <= score < 0.66\n  - confidence: 'high', 0.66 <= score <= 1.",
                  "example": {
                    "toxic": 0.8
                  },
                  "items": {
                    "format": "float",
                    "type": "number"
                  },
                  "type": "object"
                },
                "modalities": {
                  "description": "The modalities of data detected in the data.",
                  "items": {
                    "description": "Represents the modality of a some data.",
                    "properties": {
                      "group": {
                        "description": "The group of data.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups in the 'Modality' analyzer group.\n\nExample of group: application, archive, audio, code, document, executable, font,\nimage, text, unknown, video.",
                        "example": "image",
                        "type": "string"
                      },
                      "type": {
                        "description": "The type of data.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector names in the 'Modality' analyzer group.\n\nExample of type: 3dsm, 3gp, 3mf, ace, ada, ai, apk, applebplist, appleplist, ar,\narc, arj, asc, asf, asm, asp, au, autohotkey, autoit, avi, avif, awk, ax, batch,\nbazel, bcad, bib, bmp, bpg, brainfuck, brf, bzip, bzip3, c, cab, cat, cdf, chm,\nclojure, cmake, cobol, coff, coffeescript, com, cpl, cpp, crt, crx, cs, csproj,\ncss, csv, dart, deb, dex, dey, dicom, diff, django, dll, dm, dmg, dmigd,\ndmscript, doc, dockerfile, docx, dotx, dwg, dxf, dylib, elf, elixir, emf, eml,\nepub, erb, erlang, exe, flac, flv, fortran, fpx, gemfile, gemspec, gif,\ngitattributes, gitmodules, gleam, go, gradle, groovy, gzip, h, h5, handlebars,\nhaskell, hcl, heif, hlp, hpp, hta, htaccess, html, hwp, icns, ico, ics,\nignorefile, ini, internetshortcut, ipynb, iso, jar, java, javabytecode,\njavascript, jinja, jng, jnlp, jp2, jpeg, json, jsonl, jsx, julia, jxl, ko,\nkotlin, latex, lha, license, lisp, lnk, lock, lua, lz, lz4, m3u, m4, macho,\nmakefile, markdown, matlab, mht, midi, mkv, mp3, mp4, mpegts, mscompress, msi,\nmsix, mui, mum, npy, npz, objectivec, ocaml, ocx, odex, odin, odp, ods, odt,\nogg, one, onnx, otf, outlook, pascal, pcap, pdb, pdf, pebin, pem, perl, php,\npickle, png, po, postscript, powershell, ppt, pptx, prolog, proteindb, proto,\npsd, python, pythonbytecode, pytorch, qoi, qt, r, randomascii, rar, rdf, rlib,\nrll, rpm, rst, rtf, ruby, rust, scala, scheme, scr, scss, sevenzip, sgml, shell,\nsmali, snap, so, solidity, sql, sqlite, squashfs, srt, stlbinary, stltext, sum,\nsvg, swf, swift, symlinktext, sys, tar, tcl, textproto, tga, thumbsdb, tiff,\ntoml, torrent, tsv, tsx, ttf, twig, txt, txtascii, txtutf16, txtutf8,\ntypescript, vba, vbe, vcxproj, verilog, vhdl, visio, vtt, vue, wad, wasm, wav,\nwebm, webp, webtemplate, winregistry, wma, wmf, wmv, woff, woff2, xar, xcf, xls,\nxlsb, xlsx, xml, xpi, xz, yaml, yara, zig, zip, zlibstream, zst.",
                        "example": "png",
                        "type": "string"
                      }
                    },
                    "required": [
                      "group",
                      "type"
                    ],
                    "type": "object"
                  },
                  "type": "array"
                },
                "relevance": {
                  "description": "The level of general organization relevance of the input.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 < score <0.33\n  - confidence: 'medium', 0.33 <= score < 0.66\n  - confidence: 'high', 0.66 <= score <= 1.",
                  "example": 0.9,
                  "type": "number"
                },
                "secrets": {
                  "description": "The secrets found during classification.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Secrets' accross all analyzers.\n\nExample of secrets: adafruit, alibaba, anthropic, apideck, apify, atlassian,\naws_secret_key, buildkite, checkout, clickuppersonal, contentfulpersonalaccess,\ncredentials, database_url_with_credentials, databricks, denodeploy, dfuse,\ndigitalocean, discord_webhook, docker_hub, doppler, dropbox, endorlabs,\nfleetbase, flutterwave, frameio, freshdesk, fullstory, github, gitlab,\ngocardless, google_api, grafana, groq, huggingface, intra42, jwt, klaviyo,\nlaunchdarkly, linearapi, locationiq, mailchimp, mailgun, mapbox, maxmind,\nmicrosoft_teams_webhook, nightfall, notion, npm, openai, otp_auth_url, pagarme,\npaystack, planetscale, planetscaledb, portainer, posthog, postman, prefect,\nprivate_key, pubnub_publish, pubnub_subscribe, pulumi, ramp, razorpay, readme,\nrechargepayments, replicate, rubygems, salesforce, sendgrid, sendinblue,\nshopify, slack_access, slack_bot, slack_refresh, slack_user, slack_webhook,\nslack_workflow_webhook, sourcegraph, sourcegraphcody, squareapp, squareup,\nstripe, supabase, tailscale, tines_webhook, trufflehog, twilio, ubidots,\nvoiceflow, web_url_with_credentials, zapierwebhook.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 < score <0.33\n  - confidence: 'medium', 0.33 <= score < 0.66\n  - confidence: 'high', 0.66 <= score <= 1.",
                  "example": {
                    "credentials": 0.7
                  },
                  "items": {
                    "format": "float",
                    "type": "number"
                  },
                  "type": "object"
                },
                "topics": {
                  "description": "The topic of the classification.\n\nThe current list can be obtained through the analyzers API, with the following\nconditions:\n  1. Includes all analyzers EXCEPT those in the 'Modality' group\n  2. Includes all analyzer detectors EXCEPT those in these groups:\n    - 'Secrets'\n    - 'Exploits'\n    - 'Intent'\n    - 'PIIs'\n    - 'Malcontents'\n\nExample of topics: category/enterprise, category/healthcare, category/medical,\ncategory/personal, contains/blank_image, contains/certificate_signing_request,\ncontains/database_url, contains/handwritten_text, contains/printed_text,\ncontains/public_key, contains/ssh_public_key, contains/web_url,\ndecoded/base32_data, decoded/base58_data, decoded/base64_data,\ndecoded/base64_url_data, decoded/base85_data, decoded/hexadecimal_data,\ndecoded/puny_code_data, decoded/quoted_printable_data,\ndecoded/url_encoding_data, department/compliance, department/cybersecurity,\ndepartment/finance, department/human_resources,\ndepartment/information_technology, department/legal, department/logistics,\ndepartment/marketing, department/performance_evaluation,\ndepartment/product_management, department/project_management, department/sales,\ndepartment/strategy, department/support, depict/check, depict/code,\ndepict/document, depict/unclassified, depict/whiteboard, domain/commercial,\ndomain/development, domain/financial, domain/general, domain/regulatory,\ndomain/workforce, extracted/csv_cell_content, extracted/document_text_content,\nextracted/handwritten_text_content, extracted/pdf_text_content,\nextracted/pptx_text_content, extracted/spreadsheet_text_content,\nextracted/typed_text_content, timeframe/current_year, timeframe/future,\ntimeframe/last_year, timeframe/next_year, timeframe/past,\ntranscribed/audio_text_content.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 < score <0.33\n  - confidence: 'medium', 0.33 <= score < 0.66\n  - confidence: 'high', 0.66 <= score <= 1.",
                  "example": {
                    "category/enterprise": 0.7,
                    "department/logistics": 0.8,
                    "depict/document": 0.8,
                    "extracted/typed_text_content": 1,
                    "timeframe/current_year": 0.6
                  },
                  "items": {
                    "format": "float",
                    "type": "number"
                  },
                  "type": "object"
                }
              },
              "type": "object"
            },
            "type": "array"
          },
          "hash": {
            "description": "The hash of the input.",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "latency": {
            "description": "Holds information about latencies introduced by Apex.",
            "properties": {
              "accessPolicy": {
                "description": "How much time it took to run the access policy in nanoseconds.",
                "type": "integer"
              },
              "analysis": {
                "description": "How much time it took to run content analysis in nanoseconds.",
                "type": "integer"
              },
              "assignPolicy": {
                "description": "How much time it took to run the assign policy in nanoseconds.",
                "type": "integer"
              },
              "contentPolicy": {
                "description": "How much time it took to run content policy in nanoseconds.",
                "type": "integer"
              },
              "extraction": {
                "description": "How much time it took to run input or output extraction in nanoseconds.",
                "type": "integer"
              }
            },
            "type": "object"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "pipelineName": {
            "description": "The name of the particular pipeline that extracted the text.",
            "type": "string"
          },
          "principal": {
            "description": "Describe the principal.",
            "properties": {
              "IP": {
                "description": "The source IP address of the request.",
                "example": "192.0.2.42",
                "type": "string"
              },
              "app": {
                "description": "Describes the principal information of an application.",
                "properties": {
                  "component": {
                    "description": "The component of the application request.",
                    "example": "frontend",
                    "type": "string"
                  },
                  "labels": {
                    "description": "The list of labels attached to an application request.",
                    "example": [
                      "country=us",
                      "another-label"
                    ],
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "name": {
                    "description": "The name of the application.",
                    "example": "MyApp",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "authType": {
                "description": "The type of authentication.",
                "enum": [
                  "Certificate",
                  "UserToken",
                  "AppToken",
                  "Hostname",
                  "Token",
                  "ComponentToken",
                  "External"
                ]
              },
              "claims": {
                "description": "List of claims extracted from the user query.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "team": {
                "description": "The team that was used to authorize the request.",
                "example": "admins",
                "type": "string"
              },
              "tokenName": {
                "description": "The name of the token, if any.",
                "example": "my-user-token",
                "type": "string"
              },
              "type": {
                "description": "The type of principal.",
                "enum": [
                  "User",
                  "App",
                  "External"
                ],
                "example": [
                  "User"
                ]
              },
              "user": {
                "description": "Describes the principal information of a user.",
                "properties": {
                  "name": {
                    "description": "Identification bit that will be used to identify the origin of the request.",
                    "example": "user@company.com",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            },
            "required": [
              "type"
            ],
            "type": "object"
          },
          "provider": {
            "description": "the provider to use.",
            "example": "openai",
            "type": "string"
          },
          "reasons": {
            "description": "The various reasons returned by the policy engine.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "summary": {
            "description": "Represents the summary of the extractions.",
            "properties": {
              "PIIs": {
                "additionalProperties": true,
                "description": "The PIIs found during classification.",
                "type": "object"
              },
              "categories": {
                "additionalProperties": true,
                "description": "The categories are remapping of the modalities in a more human friendly way.",
                "type": "object"
              },
              "customDataSets": {
                "additionalProperties": true,
                "description": "The data sets.",
                "type": "object"
              },
              "customDataTypes": {
                "additionalProperties": true,
                "description": "The data types.",
                "type": "object"
              },
              "exploits": {
                "additionalProperties": true,
                "description": "The various exploits attempts.",
                "type": "object"
              },
              "intent": {
                "additionalProperties": true,
                "description": "The estimated intent embodied into the text.",
                "type": "object"
              },
              "keywords": {
                "additionalProperties": true,
                "description": "The keywords found during classification.",
                "type": "object"
              },
              "languages": {
                "additionalProperties": true,
                "description": "The language of the classification.",
                "type": "object"
              },
              "malcontents": {
                "additionalProperties": true,
                "description": "The various malcontents attempts.",
                "type": "object"
              },
              "modalities": {
                "additionalProperties": true,
                "description": "The modalities of data detected in the data.",
                "type": "object"
              },
              "secrets": {
                "additionalProperties": true,
                "description": "The secrets found during classification.",
                "type": "object"
              },
              "topics": {
                "additionalProperties": true,
                "description": "The topic of the classification.",
                "type": "object"
              }
            },
            "type": "object"
          },
          "time": {
            "description": "Set the time of the message request.",
            "format": "date-time",
            "type": "string"
          },
          "trace": {
            "description": "Holds all references to a trace.",
            "properties": {
              "parentSpanID": {
                "description": "The parent span ID that is being referenced.",
                "example": "00f067aa0ba902b7",
                "type": "string"
              },
              "spanEnd": {
                "description": "When the span ended.",
                "example": "2025-03-22T14:35:00.123456789Z",
                "format": "date-time",
                "type": "string"
              },
              "spanID": {
                "description": "The span ID that is being referenced.",
                "example": "6ba80aaa3b2f43d8",
                "type": "string"
              },
              "spanName": {
                "description": "The name of the span that is being collected.",
                "example": "acuvity_prompt_input_analysis",
                "type": "string"
              },
              "spanStart": {
                "description": "When the span started.",
                "example": "2025-03-22T14:35:00.123456789Z",
                "format": "date-time",
                "type": "string"
              },
              "traceID": {
                "description": "The Trace ID that is being referenced.",
                "example": "4bf92f3577b34da6a3ce929d0e0e4736",
                "type": "string"
              }
            },
            "required": [
              "spanEnd",
              "spanID",
              "spanName",
              "spanStart",
              "traceID"
            ],
            "type": "object"
          },
          "type": {
            "description": "The type of text.",
            "enum": [
              "Input",
              "Output"
            ]
          }
        },
        "required": [
          "principal"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "sinks": {
      "description": "Sinks to import.",
      "items": {
        "description": "Represents the sink used to send a notification.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "The description of the sink.",
            "type": "string"
          },
          "email": {
            "description": "Additional configuration for sending an email.",
            "properties": {
              "recipients": {
                "description": "The list of email recipients the notification will be sent to.",
                "example": [
                  "info@acuvity.ai",
                  "me@email.com"
                ],
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "required": [
              "recipients"
            ],
            "type": "object"
          },
          "friendlyName": {
            "description": "Friendly name of the object.",
            "example": "Simple name",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The internal reference name of the object. It is a sanitized version of Friendly\nName if empty.",
            "example": "my-simple-policy",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "pagerDuty": {
            "description": "Additional configuration for sending a PagerDuty event.",
            "properties": {
              "token": {
                "description": "The token for PagerDuty events.",
                "example": "0a11421bcb4c45aseve7d822fake333a",
                "type": "string"
              }
            },
            "required": [
              "token"
            ],
            "type": "object"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "slack": {
            "description": "Additional configuration for sending a Slack message.",
            "properties": {
              "webhookURL": {
                "description": "The webhook URL to send the Slack messages to.",
                "example": "https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX",
                "type": "string"
              }
            },
            "required": [
              "webhookURL"
            ],
            "type": "object"
          },
          "splunk": {
            "description": "Additional configuration for sending an alert to Splunk.",
            "properties": {
              "HECURL": {
                "description": "The HTTP event collector (HEC) URL to send the alert to.",
                "example": "https://mysplunkserver.example.com:8088/services/collector",
                "type": "string"
              },
              "certificateAuthority": {
                "description": "If set, will use this as the CA for TLS communication.",
                "type": "string"
              },
              "insecureSkipVerify": {
                "description": "If true, will attempt to skip TLS verification when communicating.",
                "type": "boolean"
              },
              "token": {
                "description": "The token to communicate with the HTTP event collector.",
                "example": "CF179AE4-3C99-45F5-A7CC-3284AA91CF67",
                "type": "string"
              }
            },
            "required": [
              "HECURL",
              "token"
            ],
            "type": "object"
          },
          "type": {
            "default": "Email",
            "description": "The type of sink.",
            "enum": [
              "Email",
              "PagerDuty",
              "Slack",
              "Splunk"
            ]
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "friendlyName",
          "type"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "teams": {
      "description": "Teams to import.",
      "items": {
        "description": "Teams can be created to create groups of people, identified by their jwt claims\nthat can be used when writing authorizations.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the team.",
            "type": "string"
          },
          "disabled": {
            "description": "Set the team to be disabled.",
            "type": "boolean"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The name of the team.",
            "example": "engineers",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "subject": {
            "description": "A tag expression that identifies user(s).",
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "weight": {
            "description": "Weight of the team. It is used if multiple teams match for a user. In that case\nthe team with the higher weight will be used.",
            "type": "integer"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "visitedurls": {
      "description": "Visited URLs to import.",
      "items": {
        "description": "This is a visited URL.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "domainHits": {
            "description": "Domain that has been visited.",
            "example": [
              {
                "domain": "google.com",
                "hits": 1
              }
            ],
            "items": {
              "description": "This is a domain hit.",
              "properties": {
                "app": {
                  "description": "The name of the application that the domain belongs to.",
                  "example": "MyApp",
                  "type": "string"
                },
                "component": {
                  "description": "The component of the application that the domain belongs to.",
                  "example": "frontend",
                  "type": "string"
                },
                "domain": {
                  "description": "Domain that has been visited.",
                  "example": "google.com",
                  "type": "string"
                },
                "hits": {
                  "description": "The number of hits for this report.",
                  "example": 12,
                  "type": "integer"
                },
                "suspicious": {
                  "description": "Suspicious is true if the service might be a Shadow AI.",
                  "type": "boolean"
                }
              },
              "required": [
                "domain",
                "hits"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "origin": {
            "default": "Proxy",
            "description": "Origin indicates from where the url has been tracked.",
            "enum": [
              "WebExtension",
              "Proxy"
            ]
          },
          "principal": {
            "description": "Describe the principal.",
            "properties": {
              "IP": {
                "description": "The source IP address of the request.",
                "example": "192.0.2.42",
                "type": "string"
              },
              "app": {
                "description": "Describes the principal information of an application.",
                "properties": {
                  "component": {
                    "description": "The component of the application request.",
                    "example": "frontend",
                    "type": "string"
                  },
                  "labels": {
                    "description": "The list of labels attached to an application request.",
                    "example": [
                      "country=us",
                      "another-label"
                    ],
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "name": {
                    "description": "The name of the application.",
                    "example": "MyApp",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "authType": {
                "description": "The type of authentication.",
                "enum": [
                  "Certificate",
                  "UserToken",
                  "AppToken",
                  "Hostname",
                  "Token",
                  "ComponentToken",
                  "External"
                ]
              },
              "claims": {
                "description": "List of claims extracted from the user query.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "team": {
                "description": "The team that was used to authorize the request.",
                "example": "admins",
                "type": "string"
              },
              "tokenName": {
                "description": "The name of the token, if any.",
                "example": "my-user-token",
                "type": "string"
              },
              "type": {
                "description": "The type of principal.",
                "enum": [
                  "User",
                  "App",
                  "External"
                ],
                "example": [
                  "User"
                ]
              },
              "user": {
                "description": "Describes the principal information of a user.",
                "properties": {
                  "name": {
                    "description": "Identification bit that will be used to identify the origin of the request.",
                    "example": "user@company.com",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            },
            "required": [
              "type"
            ],
            "type": "object"
          }
        },
        "required": [
          "domainHits",
          "origin",
          "principal"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "webExtensionConfigs": {
      "description": "Web Extension configurations to import.",
      "items": {
        "description": "WebExtensionConfig stores the configuration information for the webextension.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "allowProxySettings": {
            "description": "Allows the web extension to set the proxy settings of the employee's browser.",
            "type": "boolean"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the webextension configuration.",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The name of the webextension configuration.",
            "example": "default",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "refreshWebExtensionConfigInterval": {
            "default": 120,
            "description": "Defines the refresh interval in minutes for the configuration of the deployed\nweb extensions.",
            "type": "integer"
          },
          "reportVisitedURLsInterval": {
            "default": 60,
            "description": "Define the interval in minutes between two reports of the visited URLs.",
            "type": "integer"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "type": "array"
    }
  },
  "required": [
    "label"
  ]
}