import { z } from "zod"

export const inputParamsSchema = {
  "apply_to": z.array(z.object({ "label_selector": z.object({ "selector": z.string().describe("Label selector | The selector.") }).describe("Configuration for type LabelSelector, required if type is `label_selector`").optional(), "server": z.object({ "id": z.number().int().lte(9007199254740991).describe("ID of the Server. | ID of the [Server](#servers). | ID of the Server") }).describe("ID of the Resource").optional(), "type": z.enum(["label_selector","server"]).describe("Type of the resource.") }).describe("Resource a Firewall should be applied to.")).describe("Resources to apply the [Firewall](#firewalls) to.\n\nResources added directly are taking precedence over those added via a [Label Selector](#label-selector).\n").optional(),
  "labels": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `labels` to the tool, first call the tool `expandSchema` with \"/properties/labels\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>User-defined labels (`key/value` pairs) for the Resource.\nFor more information, see \"[Labels](#labels)\".\n</property-description>").optional(),
  "name": z.string().describe("Name of the [Firewall](#firewalls).\n\nLimited to a maximum of 128 characters.\n\nMust be unique per Project.\n"),
  "rules": z.array(z.object({ "description": z.string().max(255).nullable().describe("Description of the rule.").optional(), "destination_ips": z.array(z.string()).describe("List of permitted IPv4/IPv6 addresses for outgoing traffic.\n\nThe `direction` must be set to `out`.\n\nIPs must be in [CIDR block notation](https://wikipedia.org/wiki/CIDR). You can specify 100 CIDR\nblocks at most.\n\nThe CIDR blocks may refer to networks (with empty host bits) or single hosts.\nFor example, a network could be defined with `10.0.1.0/24` or `2001:db8:ff00:42::/64`,\nand a single host with `10.0.1.1/32` or `2001:db8:ff00:42::8329/128`.\n\nUse `0.0.0.0/0` to allow any IPv4 addresses and `::/0` to allow any IPv6 addresses.\n").optional(), "direction": z.enum(["in","out"]).describe("Traffic direction in which the rule should be applied to.\n\nUse `source_ips` for direction `in` and `destination_ips` for direction `out` to specify IPs.\n"), "port": z.string().nullable().describe("Port or port range to apply the rule for.\n\nOnly applicable for protocols `tcp` and `udp`.\n\nA port range can be specified by separating lower and upper bounds with a dash. `1024-5000` will include\nall ports starting from 1024 up to port 5000.\n").optional(), "protocol": z.enum(["esp","gre","icmp","tcp","udp"]).describe("Network protocol to apply the rule for."), "source_ips": z.array(z.string()).describe("List of permitted IPv4/IPv6 addresses for incoming traffic.\n\nThe `direction` must be set to `in`.\n\nIPs must be provided in [CIDR block notation](https://wikipedia.org/wiki/CIDR). You can specify 100 CIDR\nblocks at most.\n\nThe CIDR blocks may refer to networks (with empty host bits) or single hosts.\nFor example, a network could be defined with `10.0.1.0/24` or `2001:db8:ff00:42::/64`,\nand a single host with `10.0.1.1/32` or `2001:db8:ff00:42::8329/128`.\n\nUse `0.0.0.0/0` to allow any IPv4 addresses and `::/0` to allow any IPv6 addresses.\n").optional() }).describe("Rule of a firewall.")).describe("Array of rules.\n\nRules are limited to 50 entries per [Firewall](#firewalls) and [500 effective rules](https://docs.hetzner.com/cloud/firewalls/overview#limits).\n").optional()
}