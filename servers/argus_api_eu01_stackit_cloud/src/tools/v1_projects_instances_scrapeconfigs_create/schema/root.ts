import { z } from "zod"

export const inputParamsSchema = {
  "instanceId": z.string(),
  "projectId": z.string(),
  "basicAuth": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `basicAuth` to the tool, first call the tool `expandSchema` with \"/properties/basicAuth\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>Sets the 'Authorization' header on every scrape request with the configured username and password.\n`Additional Validators:`\n* if basicAuth is in the body no other authentication method should be in the body</property-description>").optional(),
  "bearerToken": z.string().describe("Sets the 'Authorization' header on every scrape request with the configured bearer token. It is mutually exclusive with 'bearer_token_file'.\n`Additional Validators:`\n* needs to be a valid bearer token\n* if bearerToken is in the body no other authentication method should be in the body").optional(),
  "honorLabels": z.boolean().describe("Note that any globally configured 'external_labels' are unaffected by this setting. In communication with external systems, they are always applied only when a time series does not have a given label yet and are ignored otherwise.").optional(),
  "honorTimeStamps": z.boolean().describe("honor_timestamps controls whether Prometheus respects the timestamps present in scraped data. If honor_timestamps is set to 'true', the timestamps of the metrics exposed by the target will be used.").optional(),
  "httpSdConfigs": z.array(z.object({ "basicAuth": z.object({ "password": z.string().min(1).max(200).describe("password").optional(), "username": z.string().min(1).max(200).describe("username").optional() }).describe("Sets the 'Authorization' header on every scrape request with the configured username and password.\n`Additional Validators:`\n* if basicAuth is in the body no other authentication method should be in the body").optional(), "oauth2": z.object({ "clientId": z.string().min(1).max(200).describe("clientId"), "clientSecret": z.string().min(1).max(200).describe("clientSecret"), "scopes": z.array(z.string().min(1).max(200)).describe("The URL to fetch the token from.").optional(), "tlsConfig": z.object({ "insecureSkipVerify": z.boolean().describe("Disable validation of the server certificate.") }).describe("Configures the scrape request's TLS settings.").optional(), "tokenUrl": z.string().min(1).max(200).describe("The URL to fetch the token from.") }).describe("OAuth 2.0 authentication using the client credentials grant type. Prometheus fetches an access token from the specified endpoint with the given client access and secret keys.\n`Additional Validators:`\n* if oauth2 is in the body no other authentication method should be in the body").optional(), "refreshInterval": z.string().min(2).max(8).describe("Refresh interval to re-query the endpoint. E.g. 60s\n`Additional Validators:`\n* must be a valid time format* must be >= 60s"), "tlsConfig": z.object({ "insecureSkipVerify": z.boolean().describe("Disable validation of the server certificate.") }).describe("Configures the scrape request's TLS settings.").optional(), "url": z.string().max(400).describe("URL from which the targets are fetched.") })).describe("HTTP-based service discovery provides a more generic way to configure static targets and serves as an interface to plug in custom service discovery mechanisms.").optional(),
  "jobName": z.string().min(1).max(200).describe("The job name assigned to scraped metrics by default.\n`Additional Validators:`\n* must be unique\n* key and values should only include the characters: a-zA-Z0-9-"),
  "metricsPath": z.string().min(1).max(200).describe("The HTTP resource path on which to fetch metrics from targets. E.g. /metrics").optional(),
  "metricsRelabelConfigs": z.array(z.object({ "action": z.enum(["replace","keep","drop","hashmod","labelmap","labeldrop","labelkeep"]).describe("Action to perform based on regex matching.\n`Additional Validators:`\n* if action is replace, targetLabel needs to be in body"), "modulus": z.number().describe("Modulus to take of the hash of the source label values.").optional(), "regex": z.string().min(1).max(400).describe("Regular expression against which the extracted value is matched."), "replacement": z.string().min(1).max(200).describe("Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available."), "separator": z.string().min(1).max(20).describe("Separator placed between concatenated source label values."), "sourceLabels": z.array(z.string().min(1).max(200)).describe("The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.").optional(), "targetLabel": z.string().min(1).max(200).describe("Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.").optional() })).describe("List of metric relabel configurations").optional(),
  "oauth2": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `oauth2` to the tool, first call the tool `expandSchema` with \"/properties/oauth2\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>OAuth 2.0 authentication using the client credentials grant type. Prometheus fetches an access token from the specified endpoint with the given client access and secret keys.\n`Additional Validators:`\n* if oauth2 is in the body no other authentication method should be in the body</property-description>").optional(),
  "params": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `params` to the tool, first call the tool `expandSchema` with \"/properties/params\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>Optional http params\n`Additional Validators:`\n* should not contain more than 5 keys\n* each key and value should not have more than 200 characters</property-description>").optional(),
  "sampleLimit": z.number().describe("Per-scrape limit on number of scraped samples that will be accepted. If more than this number of samples are present after metric relabeling the entire scrape will be treated as failed. The total limit depends on the service plan target limits * samples").optional(),
  "scheme": z.enum(["http","https"]).describe("Configures the protocol scheme used for requests. https or http"),
  "scrapeInterval": z.string().min(2).max(8).describe("How frequently to scrape targets from this job. E.g. 5m\n`Additional Validators:`\n* must be a valid time format* must be >= 60s"),
  "scrapeTimeout": z.string().min(2).max(8).describe("Per-scrape timeout when scraping this job.\n`Additional Validators:`\n* must be a valid time format* must be smaller than scrapeInterval"),
  "staticConfigs": z.array(z.object({ "labels": z.record(z.any()).describe("Labels assigned to all metrics scraped from the targets.\n`Additional Validators:`\n* should not contain more than 10 keys\n* each key and value should not be longer than 200 characters").optional(), "targets": z.array(z.string().min(1).max(500)).describe("The targets specified by the static config.") })).describe("A list of scrape configurations."),
  "tlsConfig": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `tlsConfig` to the tool, first call the tool `expandSchema` with \"/properties/tlsConfig\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>Configures the scrape request's TLS settings.</property-description>").optional(),
  "Authorization": z.string().describe("Accepts technical credentials and api gateway access.")
}