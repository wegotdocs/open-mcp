import { z } from "zod"

export const inputParamsSchema = {
  "continue": z.boolean().describe("Whether an alert should continue matching subsequent sibling nodes.").optional(),
  "groupBy": z.array(z.string().min(1).max(200).describe("As described")).describe("The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.").optional(),
  "groupInterval": z.string().min(2).max(8).describe("How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)\n`Additional Validators:`\n* must be a valid time format").optional(),
  "groupWait": z.string().min(2).max(8).describe("How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)\n`Additional Validators:`\n* must be a valid time format").optional(),
  "matchers": z.array(z.string().min(1).max(200).describe("Item of matchers")).describe("A list of matchers that an alert has to fulfill to match the node. A matcher is a string with a syntax inspired by PromQL and OpenMetrics. The syntax of a matcher consists of three tokens:\n* A valid Prometheus label name.\n* One of =, !=, =~, or !~. = means equals, != means that the strings are not equal, =~ is used for equality of regex expressions and !~ is used for un-equality of regex expressions. They have the same meaning as known from PromQL selectors.\n* A UTF-8 string, which may be enclosed in double quotes. Before or after each token, there may be any amount of whitespace.\n`Additional Validators:`\n* should not contain more than 5 keys\n* each key and value should not be longer than 200 characters").optional(),
  "receiver": z.string().min(1).max(200).describe("Receiver that should be one item of receivers\n`Additional Validators:`\n* must be a in name of receivers"),
  "repeatInterval": z.string().min(2).max(8).describe("How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).\n`Additional Validators:`\n* must be a valid time format").optional(),
  "routes": z.array(z.object({ "continue": z.boolean().describe("As in one level above"), "groupBy": z.array(z.string().min(1).max(200).describe("As in one level above")).optional(), "groupInterval": z.string().min(2).max(8).describe("As in one level above").optional(), "groupWait": z.string().max(8).describe("As in one level above").optional(), "matchers": z.array(z.string().min(1).max(200).describe("Item of matchers")).describe("As in one level above").optional(), "receiver": z.string().min(1).max(100).describe("As in one level above").optional(), "repeatInterval": z.string().min(2).max(8).describe("As in one level above").optional(), "routes": z.array(z.record(z.any()).describe("As in one level above")).describe("Another child routes").optional() }).describe("As in one level above")).describe("Zero or more child routes.").optional()
}