import { z } from "zod"

export const inputParams = {
  "forceNew": z.enum(["0","1"]).describe("Forces a new deployment even if there is a previous similar deployment").optional(),
  "skipAutoDetectionConfirmation": z.enum(["0","1"]).describe("Allows to skip framework detection so the API would not fail to ask for confirmation").optional(),
  "teamId": z.string().describe("The Team identifier to perform the request on behalf of.").optional(),
  "slug": z.string().describe("The Team slug to perform the request on behalf of.").optional(),
  "customEnvironmentSlugOrId": z.string().describe("Deploy to a custom environment, which will override the default environment").optional(),
  "deploymentId": z.string().describe("An deployment id for an existing deployment to redeploy").optional(),
  "files": z.array(z.object({ "data": z.string().describe("The file content, it could be either a `base64` (useful for images, etc.) of the files or the plain content for source code"), "encoding": z.enum(["base64","utf-8"]).describe("The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.").optional(), "file": z.string().describe("The file name including the whole path") }).strict().describe("Used in the case you want to inline a file inside the request")).describe("A list of objects with the files to be deployed").optional(),
  "gitMetadata": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `gitMetadata` to the tool, first call the tool `expandSchema` with \"/properties/gitMetadata\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>Populates initial git metadata for different git providers.</property-description>").optional(),
  "gitSource": z.union([z.object({ "ref": z.string(), "repoId": z.number(), "sha": z.string().optional(), "type": z.literal("github") }), z.object({ "org": z.string(), "ref": z.string(), "repo": z.string(), "sha": z.string().optional(), "type": z.literal("github") }), z.object({ "projectId": z.number(), "ref": z.string(), "sha": z.string().optional(), "type": z.literal("gitlab") }), z.object({ "ref": z.string(), "repoUuid": z.string(), "sha": z.string().optional(), "type": z.literal("bitbucket"), "workspaceUuid": z.string().optional() }), z.object({ "owner": z.string(), "ref": z.string(), "sha": z.string().optional(), "slug": z.string(), "type": z.literal("bitbucket") })]).describe("Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.").optional(),
  "meta": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `meta` to the tool, first call the tool `expandSchema` with \"/properties/meta\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>An object containing the deployment's metadata. Multiple key-value pairs can be attached to a deployment</property-description>").optional(),
  "monorepoManager": z.string().nullable().describe("The monorepo manager that is being used for this deployment. When `null` is used no monorepo manager is selected").optional(),
  "name": z.string().describe("A string with the project name used in the deployment URL"),
  "project": z.string().describe("The target project identifier in which the deployment will be created. When defined, this parameter overrides name").optional(),
  "projectSettings": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `projectSettings` to the tool, first call the tool `expandSchema` with \"/properties/projectSettings\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments</property-description>").optional(),
  "target": z.string().describe("Either not defined, `staging`, `production`, or a custom environment identifier. If `staging`, a staging alias in the format `<project>-<team>.vercel.app` will be assigned. If `production`, any aliases defined in `alias` will be assigned. If omitted, the target will be `preview`.").optional(),
  "withLatestCommit": z.boolean().describe("When `true` and `deploymentId` is passed in, the sha from the previous deployment's `gitSource` is removed forcing the latest commit to be used.").optional()
}