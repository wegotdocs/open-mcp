import { z } from "zod"

export const inputParamsSchema = {
  "description": z.string().max(128).describe("(optional) A description of the policy. ").optional(),
  "default": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `default` to the tool, first call the tool `expandSchema` with \"/properties/default\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>").optional(),
  "namespaced": z.array(z.object({ "name": z.string().regex(new RegExp("^[a-zA-Z0-9._]+$")).max(64).describe("Descriptive name for the namespaced policy definition."), "namespaces": z.array(z.string().max(1024)).describe("The namespaces that are associated with this policy definition."), "rules": z.array(z.object({ "type": z.enum(["podSecurityContext","containerSecurityContext","registry","image","tag","imagePath","vulnerabilities","cvssAttackVector","cvssAttackComplexity","cvssAvailability","checklists","checklistProfile","contents","malware","secrets","unscannedImage","unscannedImageMalware","unscannedImageSecret","podexec","portforward","capabilities"]).describe("The type of the policy rule"), "enabled": z.boolean().describe("Enable the rule"), "action": z.enum(["block","log","none"]).describe("Action to take when the rule fails during the admission control phase. Action is ignored in exceptions. It returns none if there is no record. "), "mitigation": z.enum(["log","isolate","terminate","none"]).describe("Mitigation to take when the rule fails during runtime. Mitigation is ignored in exceptions. It returns none if there is no record. "), "statement": z.union([z.object({ "properties": z.array(z.object({ "key": z.enum(["equals","not-equals","contains","not-contains","starts-with"]), "value": z.string().max(1024) }).describe("Used for Image related rules to determine the method used for matching the provided string value. ")).min(1).max(1) }).describe("The security context rule used for Image related rules to determine the method used for matching the provided string value. "), z.object({ "properties": z.array(z.object({ "key": z.literal("max-severity"), "value": z.enum(["critical","high","medium","low","negligible","unknown","none"]) }).describe("The maximum severity of scan finding that you want to allow. For example: A max-severity of high would mean that critical and defcon1 level findings are blocked.")).min(1).max(1) }).describe("The maximum severity of scan finding that you want to allow. "), z.object({ "properties": z.array(z.object({ "key": z.literal("count"), "value": z.literal("0") }).describe("The maximum number of malware or secrets that can be detected before an image is logged or blocked.")).min(1).max(1) }).describe("The rule used for logging or blocking images with a number of malware or secrets beyond the set threshold."), z.object({ "properties": z.array(z.object({ "key": z.enum(["hostPID","hostIPC","hostNetwork"]), "value": z.enum(["true","false"]) }).describe("The pod security context rule to enforce.")).min(1).max(1) }).describe("The security context rule to enforce."), z.object({ "properties": z.array(z.object({ "key": z.enum(["privileged","allowPrivilegeEscalation","runAsNonRoot","readOnlyRootFilesystem"]), "value": z.enum(["true","false"]) }).describe("The container security context rule to enforce.")).min(1).max(1) }).describe("The security context rule to enforce."), z.object({ "properties": z.array(z.union([z.object({ "key": z.literal("cvss-attack-vector"), "value": z.enum(["local/physical","adjacent","network"]) }).describe("The CVSS attack vector that you want to log/block."), z.object({ "key": z.literal("max-severity"), "value": z.enum(["critical","high","medium","low","negligible","none"]) }).describe("The maximum severity of scan finding that you want to allow. For example: A max-severity of high would mean that critical and defcon1 level findings are blocked.")])).min(1).max(2).describe("The CVSS attack vector that you want to log/block and the corresponding vulnerability’s overall severity.") }), z.object({ "properties": z.array(z.union([z.object({ "key": z.literal("cvss-attack-complexity"), "value": z.enum(["low","high"]) }).describe("The CVSS attack complexity that you want to log/block. "), z.object({ "key": z.literal("max-severity"), "value": z.enum(["critical","high","medium","low","negligible","none"]) }).describe("The maximum severity of scan finding that you want to allow. For example: A max-severity of high would mean that critical and defcon1 level findings are blocked.")])).min(1).max(2).describe("The CVSS attack complexity that you want to log/block and the corresponding vulnerability's overall severity.") }), z.object({ "properties": z.array(z.union([z.object({ "key": z.literal("cvss-availability"), "value": z.enum(["low","high"]) }).describe("The CVSS availability impact that you want to log/block. "), z.object({ "key": z.literal("max-severity"), "value": z.enum(["critical","high","medium","low","negligible","none"]) }).describe("The maximum severity of scan finding that you want to allow. For example: A max-severity of high would mean that critical and defcon1 level findings are blocked.")])).min(1).max(2).describe("The CVSS availability impact that you want to log/block and the corresponding vulnerability’s overall severity") }), z.object({ "properties": z.array(z.union([z.object({ "key": z.literal("checklist-profile"), "value": z.enum(["pci-dss","nist800190","hipaa"]) }).describe("The checklist profile to get results from."), z.object({ "key": z.literal("max-severity"), "value": z.enum(["critical","high","medium","low","negligible","unknown","none"]) }).describe("The maximum severity of scan finding that you want to allow. For example: A max-severity of high would mean that critical and defcon1 level findings are blocked.")])).min(1).max(2).describe("The checklist profile to get results from and the maximum severity of the results that you want to allow.") }), z.object({ "properties": z.array(z.object({ "key": z.literal("podExec"), "value": z.enum(["true","false"]) }).describe("The pod execution rule to enforce. ")).min(1).max(1) }).describe("The kubernetes pod execution rule."), z.object({ "properties": z.array(z.object({ "key": z.literal("podPortForward"), "value": z.enum(["true","false"]) }).describe("The pod port forward rule to enforce.")).min(1).max(1) }).describe("The kubernetes pod portforward rule."), z.object({ "properties": z.array(z.object({ "key": z.literal("capabilities-rule"), "value": z.enum(["baseline","restricted","restrict-nondefaults","restrict-all"]) }).describe("The rule for capabilities that you want to enforce\n- \"baseline\" restricts containers with the NET_RAW capability or any non-default capability\n- \"restricted\" restricts containers with any capability other than the NET_BIND_SERVICE capability\n- \"restrict-nondefaults\" restricts containers with any capability that are not already given by Docker by default\n- \"restrict-all\" restricts containers with any capability")).min(1).max(1) }).describe("The capability rule"), z.object({ "properties": z.array(z.object({ "key": z.literal("days"), "value": z.string().regex(new RegExp("^(0?[1-9]|[12][0-9]|30)$")) }).describe("The number of days that a scan result is valid.")).min(1).max(1).optional() }).describe("The scan validation duration rule.")]).optional() })).describe("The set of policy rules. The rules are OR together."), "exceptions": z.array(z.object({ "type": z.enum(["podSecurityContext","containerSecurityContext","registry","image","tag","imagePath","vulnerabilities","cvssAttackVector","cvssAttackComplexity","cvssAvailability","checklists","checklistProfile","contents","malware","secrets","unscannedImage","unscannedImageMalware","unscannedImageSecret","podexec","portforward","capabilities"]).describe("The type of the policy rule"), "enabled": z.boolean().describe("Enable the rule"), "action": z.enum(["block","log","none"]).describe("Action to take when the rule fails during the admission control phase. Action is ignored in exceptions. It returns none if there is no record. "), "mitigation": z.enum(["log","isolate","terminate","none"]).describe("Mitigation to take when the rule fails during runtime. Mitigation is ignored in exceptions. It returns none if there is no record. "), "statement": z.union([z.object({ "properties": z.array(z.object({ "key": z.enum(["equals","not-equals","contains","not-contains","starts-with"]), "value": z.string().max(1024) }).describe("Used for Image related rules to determine the method used for matching the provided string value. ")).min(1).max(1) }).describe("The security context rule used for Image related rules to determine the method used for matching the provided string value. "), z.object({ "properties": z.array(z.object({ "key": z.literal("max-severity"), "value": z.enum(["critical","high","medium","low","negligible","unknown","none"]) }).describe("The maximum severity of scan finding that you want to allow. For example: A max-severity of high would mean that critical and defcon1 level findings are blocked.")).min(1).max(1) }).describe("The maximum severity of scan finding that you want to allow. "), z.object({ "properties": z.array(z.object({ "key": z.literal("count"), "value": z.literal("0") }).describe("The maximum number of malware or secrets that can be detected before an image is logged or blocked.")).min(1).max(1) }).describe("The rule used for logging or blocking images with a number of malware or secrets beyond the set threshold."), z.object({ "properties": z.array(z.object({ "key": z.enum(["hostPID","hostIPC","hostNetwork"]), "value": z.enum(["true","false"]) }).describe("The pod security context rule to enforce.")).min(1).max(1) }).describe("The security context rule to enforce."), z.object({ "properties": z.array(z.object({ "key": z.enum(["privileged","allowPrivilegeEscalation","runAsNonRoot","readOnlyRootFilesystem"]), "value": z.enum(["true","false"]) }).describe("The container security context rule to enforce.")).min(1).max(1) }).describe("The security context rule to enforce."), z.object({ "properties": z.array(z.union([z.object({ "key": z.literal("cvss-attack-vector"), "value": z.enum(["local/physical","adjacent","network"]) }).describe("The CVSS attack vector that you want to log/block."), z.object({ "key": z.literal("max-severity"), "value": z.enum(["critical","high","medium","low","negligible","none"]) }).describe("The maximum severity of scan finding that you want to allow. For example: A max-severity of high would mean that critical and defcon1 level findings are blocked.")])).min(1).max(2).describe("The CVSS attack vector that you want to log/block and the corresponding vulnerability’s overall severity.") }), z.object({ "properties": z.array(z.union([z.object({ "key": z.literal("cvss-attack-complexity"), "value": z.enum(["low","high"]) }).describe("The CVSS attack complexity that you want to log/block. "), z.object({ "key": z.literal("max-severity"), "value": z.enum(["critical","high","medium","low","negligible","none"]) }).describe("The maximum severity of scan finding that you want to allow. For example: A max-severity of high would mean that critical and defcon1 level findings are blocked.")])).min(1).max(2).describe("The CVSS attack complexity that you want to log/block and the corresponding vulnerability's overall severity.") }), z.object({ "properties": z.array(z.union([z.object({ "key": z.literal("cvss-availability"), "value": z.enum(["low","high"]) }).describe("The CVSS availability impact that you want to log/block. "), z.object({ "key": z.literal("max-severity"), "value": z.enum(["critical","high","medium","low","negligible","none"]) }).describe("The maximum severity of scan finding that you want to allow. For example: A max-severity of high would mean that critical and defcon1 level findings are blocked.")])).min(1).max(2).describe("The CVSS availability impact that you want to log/block and the corresponding vulnerability’s overall severity") }), z.object({ "properties": z.array(z.union([z.object({ "key": z.literal("checklist-profile"), "value": z.enum(["pci-dss","nist800190","hipaa"]) }).describe("The checklist profile to get results from."), z.object({ "key": z.literal("max-severity"), "value": z.enum(["critical","high","medium","low","negligible","unknown","none"]) }).describe("The maximum severity of scan finding that you want to allow. For example: A max-severity of high would mean that critical and defcon1 level findings are blocked.")])).min(1).max(2).describe("The checklist profile to get results from and the maximum severity of the results that you want to allow.") }), z.object({ "properties": z.array(z.object({ "key": z.literal("podExec"), "value": z.enum(["true","false"]) }).describe("The pod execution rule to enforce. ")).min(1).max(1) }).describe("The kubernetes pod execution rule."), z.object({ "properties": z.array(z.object({ "key": z.literal("podPortForward"), "value": z.enum(["true","false"]) }).describe("The pod port forward rule to enforce.")).min(1).max(1) }).describe("The kubernetes pod portforward rule."), z.object({ "properties": z.array(z.object({ "key": z.literal("capabilities-rule"), "value": z.enum(["baseline","restricted","restrict-nondefaults","restrict-all"]) }).describe("The rule for capabilities that you want to enforce\n- \"baseline\" restricts containers with the NET_RAW capability or any non-default capability\n- \"restricted\" restricts containers with any capability other than the NET_BIND_SERVICE capability\n- \"restrict-nondefaults\" restricts containers with any capability that are not already given by Docker by default\n- \"restrict-all\" restricts containers with any capability")).min(1).max(1) }).describe("The capability rule"), z.object({ "properties": z.array(z.object({ "key": z.literal("days"), "value": z.string().regex(new RegExp("^(0?[1-9]|[12][0-9]|30)$")) }).describe("The number of days that a scan result is valid.")).min(1).max(1).optional() }).describe("The scan validation duration rule.")]).optional() })).describe("The set of policy rules. The rules are OR together.").optional() })).describe("The definition of all the policies.").optional(),
  "runtime": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `runtime` to the tool, first call the tool `expandSchema` with \"/properties/runtime\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The runtime properties of this policy.</property-description>").optional(),
  "xdrEnabled": z.boolean().describe("If true, enables XDR telemetry. \n\n> **Important**\n>\n> To use XDR telemetry, enable runtime security.\n").optional(),
  "malwareScan": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `malwareScan` to the tool, first call the tool `expandSchema` with \"/properties/malwareScan\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The Runtime Malware Scanning configuration of this policy. </property-description>").optional(),
  "secretScan": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `secretScan` to the tool, first call the tool `expandSchema` with \"/properties/secretScan\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The Runtime Secret Scanning configuration for the policy. </property-description>").optional()
}