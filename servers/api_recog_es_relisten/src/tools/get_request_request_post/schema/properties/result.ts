import { z } from "zod"

export const inputParamsSchema = {
  "lang": z.string().describe("Target language for the notes. It may be different from the language of the audio. If it is indeed different, we will translate the transcription and the notes to the target language."),
  "langCult": z.string().describe("Target language culture for the notes.").optional(),
  "userRole": z.string().describe("User role in the consultation.").optional(),
  "country": z.string().describe("Country of the consultation.").optional(),
  "healthCenterGroup": z.string().describe("Optional health center group.").optional(),
  "healthCenter": z.string().describe("Optional health center.").optional(),
  "specialty": z.string().describe("Specialty of the consultation.").optional(),
  "subSpecialty": z.string().describe("Optional sub specialty. If not specified, the specialty will be used.").optional(),
  "subSubSpecialty": z.string().describe("Optional sub sub specialty.").optional(),
  "consultationType": z.enum(["","background","firstVisit","followUp"]).describe("Type of consultation.").optional(),
  "initialContext": z.union([z.string(), z.null()]).describe("Optional initial context.").optional(),
  "isMulti": z.boolean().describe("If it is a multi-consultation visit, i.e. a visit with multiple cosultation reasons.").optional(),
  "createdAt": z.string().describe("The date and time when the record was created.").optional(),
  "updatedAt": z.string().describe("The date and time when the record was updated.").optional(),
  "updatedBy": z.string().describe("The user who updated the record.").optional(),
  "resultid": z.string().describe("The unique identifier for the result in our system."),
  "status": z.enum(["pending","processing","completed","error","waiting_for_trigger"]).describe("The status of the result.").optional(),
  "transcription": z.union([z.object({ "segments": z.array(z.object({ "start": z.number().int().describe("The timestamp of the start of the segment."), "tokens": z.union([z.array(z.number().int()), z.null()]).describe("The tokens of the segment.").optional(), "end": z.number().int().describe("The timestamp of the end of the segment."), "text": z.string().describe("The text of the segment.") }).describe("Segment.")).describe("The segments of the transcription."), "embeddings": z.array(z.array(z.number())) }).describe("Transcription."), z.null()]).describe("The transcription of the consultation.").optional(),
  "errorCode": z.union([z.enum(["api","llm","transcription","censor_filter","consultation_too_short","unknown","building_pipeline","rate_limit","coding"]).describe("Error code enum."), z.null()]).describe("The error code of the result if any.").optional(),
  "failedFields": z.array(z.string()).describe("If the consultation failed to be processed, this field will contain the list of failed fields for the doctor to review.").optional(),
  "answers": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `answers` to the tool, first call the tool `expandSchema` with \"/properties/result/properties/answers\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The clinical notes generated for the consultation.</property-description>").optional(),
  "multiAnswers": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `multiAnswers` to the tool, first call the tool `expandSchema` with \"/properties/result/properties/multiAnswers\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>In case of a multi-consultation visit, those fields which change from one reason to another will be stored here.</property-description>").optional(),
  "sources": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `sources` to the tool, first call the tool `expandSchema` with \"/properties/result/properties/sources\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The part of the transcription where the information was extracted. This is useful to quickly identify the source of the information in case of doubts.</property-description>").optional(),
  "expdate": z.number().int().describe("The expiration timestamp for the result in seconds.").optional(),
  "username": z.string().optional(),
  "reviewTime": z.union([z.number().int(), z.null()]).describe("The time it took to review the result in seconds.").optional(),
  "processTime": z.union([z.number().int(), z.null()]).describe("The time it took to process the result in seconds.").optional(),
  "audioDuration": z.union([z.number().int(), z.null()]).describe("The duration of the audio in seconds.").optional(),
  "piiEntities": z.union([z.array(z.object({ "beginOffset": z.number().int(), "endOffset": z.number().int(), "entityType": z.enum(["","ADDRESS","AGE","AWS_ACCESS_KEY","AWS_SECRET_KEY","CREDIT_DEBIT_CVV","CREDIT_DEBIT_EXPIRY","CREDIT_DEBIT_NUMBER","DATE_TIME","DRIVER_ID","EMAIL","INTERNATIONAL_BANK_ACCOUNT_NUMBER","IP_ADDRESS","LICENSE_PLATE","MAC_ADDRESS","NAME","PASSWORD","PHONE","PIN","SWIFT_CODE","URL","USERNAME","VEHICLE_IDENTIFICATION_NUMBER","CA_HEALTH_NUMBER","CA_SOCIAL_INSURANCE_NUMBER","IN_AADHAAR","IN_NREGA","IN_PERMANENT_ACCOUNT_NUMBER","IN_VOTE_NUMBER","UK_NATIONAL_HEALTH_SERVICE_NUMBER","UK_NATIONAL_INSURANCE_NUMBER","UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER","BANK_ACCOUNT_NUMBER","BANK_ROUTING","PASSPORT_NUMBER","US_INDIVIDUAL_TAXPAYER_IDENTIFICATION_NUMBER","SSN"]).describe("Enum for PII types."), "score": z.union([z.number(), z.string()]) }).describe("PII entity model.")), z.null()]).describe("The PII entities found in the transcription. This is not enable for now.").optional(),
  "tags": z.union([z.record(z.any()), z.null()]).describe("The tags of the result.").optional(),
  "callbackUrl": z.union([z.string(), z.null()]).describe("The URL to call when the result is ready. The body of the request will be the result in JSON format.").optional(),
  "title": z.union([z.string(), z.null()]).describe("The title of the consultation.").optional(),
  "coding": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `coding` to the tool, first call the tool `expandSchema` with \"/properties/result/properties/coding\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The coding information of the consultation. This dictionary follows the same schema as in `answers` with the coding that applies to each field, if any.</property-description>").optional()
}