import { z } from "zod"

export const toolName = `updateworkflows`
export const toolDescription = `Bulk update workflows`
export const baseUrl = `https://your-domain.atlassian.net`
export const path = `/rest/api/3/workflows/update`
export const method = `post`
export const security = [
  {
    "key": "Authorization",
    "value": "Basic <mcp-env-var>USERNAME_PASSWORD_BASE64</mcp-env-var>",
    "in": "header",
    "envVarName": "USERNAME_PASSWORD_BASE64",
    "schemeType": "http",
    "schemeScheme": "basic"
  },
  {
    "key": "Authorization",
    "value": "Bearer <mcp-env-var>OAUTH2_TOKEN</mcp-env-var>",
    "in": "header",
    "envVarName": "OAUTH2_TOKEN",
    "schemeType": "oauth2"
  }
]
export const keys = {
  "query": [
    "expand"
  ],
  "header": [],
  "path": [],
  "cookie": [],
  "body": [
    "statuses",
    "workflows"
  ]
}
export const flatMap = {}

export const inputParams = z.object({ "expand": z.string().describe("Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:\n\n *  `workflows.usages` Returns the project and issue types that each workflow is associated with.\n *  `statuses.usages` Returns the project and issue types that each status is associated with.").optional(), "statuses": z.array(z.object({ "description": z.string().describe("The description of the status.").optional(), "id": z.string().describe("The ID of the status.").optional(), "name": z.string().describe("The name of the status."), "statusCategory": z.enum(["TODO","IN_PROGRESS","DONE"]).describe("The category of the status."), "statusReference": z.string().describe("The reference of the status.") }).catchall(z.any()).describe("Details of the status being updated.")).describe("The statuses to associate with the workflows.").optional(), "workflows": z.array(z.object({ "defaultStatusMappings": z.array(z.object({ "newStatusReference": z.string().describe("The new status ID."), "oldStatusReference": z.string().describe("The old status ID.") }).catchall(z.any()).describe("The mapping of old to new status ID.")).describe("The mapping of old to new status ID.").optional(), "description": z.string().describe("The new description for this workflow.").optional(), "id": z.string().describe("The ID of this workflow."), "startPointLayout": z.object({ "x": z.number().describe("The x axis location.").optional(), "y": z.number().describe("The y axis location.").optional() }).strict().nullable().describe("The starting point for the statuses in the workflow.").optional(), "statusMappings": z.array(z.object({ "issueTypeId": z.string().describe("The issue type for the status mapping."), "projectId": z.string().describe("The project for the status mapping."), "statusMigrations": z.array(z.object({ "newStatusReference": z.string().describe("The new status ID."), "oldStatusReference": z.string().describe("The old status ID.") }).catchall(z.any()).describe("The mapping of old to new status ID.")).describe("The list of old and new status ID mappings for the specified project and issue type.") }).catchall(z.any()).describe("The mapping of old to new status ID for a specific project and issue type.")).describe("The mapping of old to new status ID for a specific project and issue type.").optional(), "statuses": z.array(z.object({ "approvalConfiguration": z.object({ "active": z.enum(["true","false"]).describe("Whether the approval configuration is active."), "conditionType": z.enum(["number","percent","numberPerPrincipal"]).describe("How the required approval count is calculated. It may be configured to require a specific number of approvals, or approval by a percentage of approvers. If the approvers source field is Approver groups, you can configure how many approvals per group are required for the request to be approved. The number will be the same across all groups."), "conditionValue": z.string().describe("The number or percentage of approvals required for a request to be approved. If `conditionType` is `number`, the value must be 20 or less. If `conditionType` is `percent`, the value must be 100 or less."), "exclude": z.array(z.enum(["assignee","reporter"]).nullable().describe("A list of roles that should be excluded as possible approvers.")).nullable().describe("A list of roles that should be excluded as possible approvers.").optional(), "fieldId": z.string().describe("The custom field ID of the \"Approvers\" or \"Approver Groups\" field."), "prePopulatedFieldId": z.string().nullable().describe("The custom field ID of the field used to pre-populate the Approver field. Only supports the \"Affected Services\" field.").optional(), "transitionApproved": z.string().describe("The numeric ID of the transition to be executed if the request is approved."), "transitionRejected": z.string().describe("The numeric ID of the transition to be executed if the request is declined.") }).strict().nullable().describe("The approval configuration of a status within a workflow. Applies only to Jira Service Management approvals.").optional(), "layout": z.object({ "x": z.number().describe("The x axis location.").optional(), "y": z.number().describe("The y axis location.").optional() }).strict().nullable().describe("The starting point for the statuses in the workflow.").optional(), "properties": z.record(z.string().describe("The properties for this status layout.")).describe("The properties for this status layout."), "statusReference": z.string().describe("A unique ID which the status will use to refer to this layout configuration.") }).catchall(z.any()).describe("The statuses associated with this workflow.")).describe("The statuses associated with this workflow."), "transitions": z.array(z.object({ "actions": z.array(z.object({ "id": z.string().nullable().describe("The ID of the rule.").optional(), "parameters": z.record(z.string().describe("The parameters related to the rule.")).describe("The parameters related to the rule.").optional(), "ruleKey": z.string().describe("The rule key of the rule.") }).strict().nullable().describe("The configuration of the rule.")).describe("The post-functions of the transition.").optional(), "conditions": z.object({ "conditionGroups": z.array(z.object({ "conditionGroups": z.array(z.object({ "conditionGroups": z.array(z.object({ "conditionGroups": z.array(z.object({ "conditionGroups": z.array(z.object({ "conditionGroups": z.array(z.object({ "conditionGroups": z.array(z.string()).describe("The nested conditions of the condition group.").optional(), "conditions": z.array(z.string()).describe("The rules for this condition.").optional(), "operation": z.enum(["ANY","ALL"]).describe("Determines how the conditions in the group are evaluated. Accepts either `ANY` or `ALL`. If `ANY` is used, at least one condition in the group must be true for the group to evaluate to true. If `ALL` is used, all conditions in the group must be true for the group to evaluate to true.") }).strict().nullable().describe("The conditions group associated with the transition.")).describe("The nested conditions of the condition group.").optional(), "conditions": z.array(z.object({ "id": z.string().nullable().describe("The ID of the rule.").optional(), "parameters": z.record(z.string()).describe("The parameters related to the rule.").optional(), "ruleKey": z.string().describe("The rule key of the rule.") }).strict().nullable().describe("The configuration of the rule.")).describe("The rules for this condition.").optional(), "operation": z.enum(["ANY","ALL"]).describe("Determines how the conditions in the group are evaluated. Accepts either `ANY` or `ALL`. If `ANY` is used, at least one condition in the group must be true for the group to evaluate to true. If `ALL` is used, all conditions in the group must be true for the group to evaluate to true.") }).strict().nullable().describe("The conditions group associated with the transition.")).describe("The nested conditions of the condition group.").optional(), "conditions": z.array(z.object({ "id": z.string().nullable().describe("The ID of the rule.").optional(), "parameters": z.record(z.string().describe("The parameters related to the rule.")).describe("The parameters related to the rule.").optional(), "ruleKey": z.string().describe("The rule key of the rule.") }).strict().nullable().describe("The configuration of the rule.")).describe("The rules for this condition.").optional(), "operation": z.enum(["ANY","ALL"]).describe("Determines how the conditions in the group are evaluated. Accepts either `ANY` or `ALL`. If `ANY` is used, at least one condition in the group must be true for the group to evaluate to true. If `ALL` is used, all conditions in the group must be true for the group to evaluate to true.") }).strict().nullable().describe("The conditions group associated with the transition.")).describe("The nested conditions of the condition group.").optional(), "conditions": z.array(z.object({ "id": z.string().nullable().describe("The ID of the rule.").optional(), "parameters": z.record(z.string().describe("The parameters related to the rule.")).describe("The parameters related to the rule.").optional(), "ruleKey": z.string().describe("The rule key of the rule.") }).strict().nullable().describe("The configuration of the rule.")).describe("The rules for this condition.").optional(), "operation": z.enum(["ANY","ALL"]).describe("Determines how the conditions in the group are evaluated. Accepts either `ANY` or `ALL`. If `ANY` is used, at least one condition in the group must be true for the group to evaluate to true. If `ALL` is used, all conditions in the group must be true for the group to evaluate to true.") }).strict().nullable().describe("The conditions group associated with the transition.")).describe("The nested conditions of the condition group.").optional(), "conditions": z.array(z.object({ "id": z.string().nullable().describe("The ID of the rule.").optional(), "parameters": z.record(z.string().describe("The parameters related to the rule.")).describe("The parameters related to the rule.").optional(), "ruleKey": z.string().describe("The rule key of the rule.") }).strict().nullable().describe("The configuration of the rule.")).describe("The rules for this condition.").optional(), "operation": z.enum(["ANY","ALL"]).describe("Determines how the conditions in the group are evaluated. Accepts either `ANY` or `ALL`. If `ANY` is used, at least one condition in the group must be true for the group to evaluate to true. If `ALL` is used, all conditions in the group must be true for the group to evaluate to true.") }).strict().nullable().describe("The conditions group associated with the transition.")).describe("The nested conditions of the condition group.").optional(), "conditions": z.array(z.object({ "id": z.string().nullable().describe("The ID of the rule.").optional(), "parameters": z.record(z.string().describe("The parameters related to the rule.")).describe("The parameters related to the rule.").optional(), "ruleKey": z.string().describe("The rule key of the rule.") }).strict().nullable().describe("The configuration of the rule.")).describe("The rules for this condition.").optional(), "operation": z.enum(["ANY","ALL"]).describe("Determines how the conditions in the group are evaluated. Accepts either `ANY` or `ALL`. If `ANY` is used, at least one condition in the group must be true for the group to evaluate to true. If `ALL` is used, all conditions in the group must be true for the group to evaluate to true.") }).strict().nullable().describe("The conditions group associated with the transition.")).describe("The nested conditions of the condition group.").optional(), "conditions": z.array(z.object({ "id": z.string().nullable().describe("The ID of the rule.").optional(), "parameters": z.record(z.string().describe("The parameters related to the rule.")).describe("The parameters related to the rule.").optional(), "ruleKey": z.string().describe("The rule key of the rule.") }).strict().nullable().describe("The configuration of the rule.")).describe("The rules for this condition.").optional(), "operation": z.enum(["ANY","ALL"]).describe("Determines how the conditions in the group are evaluated. Accepts either `ANY` or `ALL`. If `ANY` is used, at least one condition in the group must be true for the group to evaluate to true. If `ALL` is used, all conditions in the group must be true for the group to evaluate to true.") }).strict().nullable().describe("The conditions group associated with the transition.").optional(), "customIssueEventId": z.string().describe("The custom event ID of the transition.").optional(), "description": z.string().describe("The description of the transition.").optional(), "id": z.string().describe("The ID of the transition.").optional(), "links": z.array(z.object({ "fromPort": z.number().int().nullable().describe("The port that the transition starts from.").optional(), "fromStatusReference": z.string().nullable().describe("The status that the transition starts from.").optional(), "toPort": z.number().int().nullable().describe("The port that the transition goes to.").optional() }).strict().nullable().describe("The statuses the transition can start from, and the mapping of ports between the statuses.")).describe("The statuses the transition can start from, and the mapping of ports between the statuses.").optional(), "name": z.string().describe("The name of the transition.").optional(), "properties": z.record(z.string().describe("The properties of the transition.")).describe("The properties of the transition.").optional(), "toStatusReference": z.string().describe("The status the transition goes to.").optional(), "transitionScreen": z.object({ "id": z.string().nullable().describe("The ID of the rule.").optional(), "parameters": z.record(z.string().describe("The parameters related to the rule.")).describe("The parameters related to the rule.").optional(), "ruleKey": z.string().describe("The rule key of the rule.") }).strict().nullable().describe("The configuration of the rule.").optional(), "triggers": z.array(z.object({ "id": z.string().describe("The ID of the trigger.").optional(), "parameters": z.record(z.string().describe("The parameters of the trigger.")).describe("The parameters of the trigger."), "ruleKey": z.string().describe("The rule key of the trigger.") }).strict().describe("The trigger configuration associated with a workflow.")).describe("The triggers of the transition.").optional(), "type": z.enum(["INITIAL","GLOBAL","DIRECTED"]).describe("The transition type.").optional(), "validators": z.array(z.object({ "id": z.string().nullable().describe("The ID of the rule.").optional(), "parameters": z.record(z.string().describe("The parameters related to the rule.")).describe("The parameters related to the rule.").optional(), "ruleKey": z.string().describe("The rule key of the rule.") }).strict().nullable().describe("The configuration of the rule.")).describe("The validators of the transition.").optional() }).catchall(z.any()).describe("The transition update data.")).describe("The transitions of this workflow."), "version": z.object({ "id": z.string().describe("The version UUID.").optional(), "versionNumber": z.number().int().describe("The version number.").optional() }).strict().describe("The current version details of this workflow scheme.") }).catchall(z.any()).describe("The details of the workflows to update.")).describe("The details of the workflows to update.").optional() }).shape