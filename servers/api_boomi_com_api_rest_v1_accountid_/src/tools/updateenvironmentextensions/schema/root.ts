import { z } from "zod"

export const inputParamsSchema = {
  "id": z.string().describe("The ID of the object. This can be either of the following: \n 1. The value of environmentId. \n 2. A conceptual ID synthesized from the environment ID (environmentId) and the ID of the multi-install integration pack to which the extension values apply (extensionGroupId)."),
  "PGPCertificates": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `PGPCertificates` to the tool, first call the tool `expandSchema` with \"/properties/PGPCertificates\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>"),
  "connections": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `connections` to the tool, first call the tool `expandSchema` with \"/properties/connections\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>"),
  "crossReferences": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `crossReferences` to the tool, first call the tool `expandSchema` with \"/properties/crossReferences\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>"),
  "environmentId": z.string().describe("The ID of the environment.").optional(),
  "extensionGroupId": z.string().describe("The synthesized ID of the process belonging to a multi-install integration pack to which the extension values apply, if applicable. For more information, see the section in the Working with Environment Extensions subtopic about multi-install integration packs.").optional(),
  "b_id": z.string().describe("The ID of the object. This can be either of the following:<br /> 1. The value of environmentId.<br /> 2. A conceptual ID synthesized from the environment ID \\(environmentId\\) and the ID of the multi-install integration pack to which the extension values apply \\(extensionGroupId\\).").optional(),
  "operations": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `operations` to the tool, first call the tool `expandSchema` with \"/properties/operations\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>"),
  "partial": z.boolean().describe("Supplied only in an UPDATE operation. <br />-   If set to true, indicates that the request includes only a subset of environment extension values to update. <br /> -   If set to false, indicates that the request includes the full set of environment extension values to update. Values not included in the request are reset to use their default values.").optional(),
  "processProperties": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `processProperties` to the tool, first call the tool `expandSchema` with \"/properties/processProperties\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>"),
  "properties": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `properties` to the tool, first call the tool `expandSchema` with \"/properties/properties\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>"),
  "sharedCommunications": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `sharedCommunications` to the tool, first call the tool `expandSchema` with \"/properties/sharedCommunications\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>"),
  "tradingPartners": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `tradingPartners` to the tool, first call the tool `expandSchema` with \"/properties/tradingPartners\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>")
}