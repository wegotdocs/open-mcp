import { z } from "zod"

export const toolName = `listprogrammes`
export const toolDescription = `Start here for programmes metadata: Brands, Series, Episodes and Clips`
export const baseUrl = `https://programmes.api.bbc.com`
export const path = `/programmes`
export const method = `get`
export const security = [
  {
    "key": "api_key",
    "value": "<mcp-env-var>API_KEY</mcp-env-var>",
    "in": "query",
    "envVarName": "API_KEY",
    "schemeType": "apiKey",
    "schemeName": "api_key"
  }
]

export const inputParams = z.object({ "query": z.object({ "sort": z.enum(["group_position","pid","position","promotion","release_date","relevance","scheduled_start","strict_title","title","tree"]).describe("Sorts:\n* group_position: sort numerically by position in group, ascending\n* pid: sort alphabetically by PID, descending\n* position: sort numerically by position, ascending\n* promotion: sort by promotion rank, ascending\n* release_date: sort chronologically by release date, descending\n* relevance: sort by weighting of search term (use with q parameter)\n* scheduled_start: sort chronologically by scheduled start time/date, ascending\n* strict_title: sort alphabetically by title, ascending\n* title: sort by title librarian style (ignoring leading 'The', 'A', etc), ascending\n* tree: sort by root pid and then preorder tree sort. Requires entities to have release date.\n").optional(), "sort_direction": z.enum(["ascending","descending"]).describe("Sort direction").optional(), "mixin": z.array(z.enum(["alternate_images","ancestor_titles","availability","available_simulcasts","available_versions","available_webcasts","contributions","duration","genre_groupings","genre_groups","images","is_embeddable","previous_next","programme_type","related_links","titles","versions_availability"])).describe("Mixins:\n* alternate_images: mixin to return the alternate images for a programme\n* ancestor_titles: mixin to return ancestor programme titles\n* availability: mixin to return programme availability information\n* available_simulcasts: mixin to return information about programmes that are currently available as simulcasts\n* available_versions: mixin to return information about programmes that are currently available on demand\n* available_webcasts: mixin to return information about programmes that are currently available as webcasts\n* contributions: mixin to return information about contributors to a programme\n* duration: mixin to return original version duration in programme concept entities\n* genre_groupings: mixin to return list of genre groupings\n* genre_groups: mixin to return list of genre groups\n* images: mixin to add image information for a programme\n* is_embeddable: mixin to add embeddable information for a programme\n* previous_next: mixin to return the programmes which appear before and after a programme (as determined by the sort applied in the request)\n* programme_type: mixin to return the programme type\n* related_links: mixin to return information about related links to a programme\n* titles: mixin to return ancestor programme titles\n* versions_availability: mixin to return information about programmes that are currently available\n").optional(), "audio_described": z.array(z.enum(["true","false"])).describe("filter for subset of programmes that are audio-described").optional(), "availability": z.array(z.enum(["available","pending"])).describe("filter for subset of programmes that have availability").optional(), "availability_entity_type": z.array(z.enum(["episode","clip"])).describe("additional filter when availability=available").optional(), "availability_from": z.string().datetime({ offset: true }).describe("filter for subset of programmes that are available after or at the specified datetime").optional(), "availability_type": z.array(z.enum(["ondemand","webcast","simulcast"])).describe("filter for a subset of programmes that are available for a given type").optional(), "children_of": z.array(z.string().regex(new RegExp("^([0-9,a-d,f-h,j-n,p-t,v-z]){8,}$")).min(8)).describe("filter for subset of programmes that have PID as immediate parent").optional(), "descendants_of": z.array(z.string().regex(new RegExp("^([0-9,a-d,f-h,j-n,p-t,v-z]){8,}$")).min(8)).describe("filter for subset of programmes that have PID as ancestor").optional(), "duration": z.array(z.enum(["short","medium","long"])).describe("filter for subset of programmes that have given duration").optional(), "entity_type": z.array(z.enum(["brand","series","episode","clip"])).describe("filter for subset of programmes that have given entity type").optional(), "format": z.array(z.string()).describe("filter for subset of programmes with format").optional(), "genre": z.array(z.string()).describe("filter for subset of programmes with genre").optional(), "group": z.string().regex(new RegExp("^([0-9,a-d,f-h,j-n,p-t,v-z]){8,}$")).min(8).describe("filter for subset of programmes which belong to the given group pid").optional(), "initial_letter": z.string().min(1).max(1).describe("filter for subset of programmes with title beginning with initial letter librarian style (ignoring leading 'The', 'An' (Welsh), etc) 0-9 a-z").optional(), "initial_letter_end": z.string().min(1).max(1).describe("Programmes with (librarian) titles whose initial letter is equal/before given letter. Use with initial_letter_start for a range").optional(), "initial_letter_start": z.string().min(1).max(1).describe("Programmes with (librarian) titles whose initial letter is equal/after given letter. Use with initial_letter_end for range.").optional(), "initial_letter_strict": z.array(z.string().min(1).max(1)).describe("filter for subset of programmes with title beginning with initial letter").optional(), "item": z.array(z.string().regex(new RegExp("^([0-9,a-d,f-h,j-n,p-t,v-z]){8,}$")).min(8)).describe("filter for subset of programmes with linked to versions which have the given item pids").optional(), "master_brand": z.array(z.string()).describe("filter for subset of programmes with master_brand").optional(), "media_set": z.string().describe("filter for subset of programmes with media set").optional(), "media_type": z.array(z.enum(["audio","audio_video"])).describe("filter for subset of programmes with media type").optional(), "page": z.number().int().gte(1).describe("which page of results to return"), "page_size": z.number().int().lte(300).describe("number of results in each page"), "partner_id": z.array(z.string().regex(new RegExp("^([0-9,a-d,f-h,j-n,p-t,v-z]){8,}$")).min(8)).describe("filter for programmes by partner ID").optional(), "partner_pid": z.array(z.string().regex(new RegExp("^([0-9,a-d,f-h,j-n,p-t,v-z]){8,}$")).min(8)).describe("filter for programmes by partner PID").optional(), "payment_type": z.array(z.enum(["free","bbcstore","uscansvod"])).describe("filter for a subset of programmes that are of the given payment_type").optional(), "people": z.string().regex(new RegExp("^([0-9,a-d,f-h,j-n,p-t,v-z]){8,}$")).min(8).describe("filter for subset of programmes with contributions by given people PID").optional(), "pid": z.array(z.string().regex(new RegExp("^([0-9,a-d,f-h,j-n,p-t,v-z]){8,}$")).min(8)).describe("filter for subset of programmes having given PID").optional(), "promoted_for": z.string().describe("filter for subset of programmes which are promoted for given service").optional(), "q": z.string().describe("filter for subset of programmes matching supplied keyword/phrase (boolean operators permitted)").optional(), "signed": z.array(z.enum(["exclusive","inclusive","exclude"])).describe("filter for subset of programmes that are signed").optional(), "tag_name": z.string().describe("filter for subset of programmes with tag").optional(), "tag_scheme": z.string().describe("filter for subset of programmes with a tag").optional(), "tleo": z.array(z.enum(["true","false"])).describe("filter for subset of programmes that are TLEOs").optional(), "version": z.array(z.string().regex(new RegExp("^([0-9,a-d,f-h,j-n,p-t,v-z]){8,}$")).min(8)).describe("filter for subset of programmes with given PID as one of their versions").optional(), "embargoed": z.enum(["include","exclude","only"]).describe("Control return of embargoed items (undocumented)").optional() }).optional() }).shape