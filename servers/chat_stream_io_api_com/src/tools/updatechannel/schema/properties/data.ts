import { z } from "zod"

export const inputParamsSchema = {
  "auto_translation_enabled": z.boolean().describe("Enable or disable auto translation").optional(),
  "auto_translation_language": z.string().describe("Switch auto translation language").optional(),
  "config_overrides": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `config_overrides` to the tool, first call the tool `expandSchema` with \"/properties/data/properties/config_overrides\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>Channel configuration overrides</property-description>").optional(),
  "created_by": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `created_by` to the tool, first call the tool `expandSchema` with \"/properties/data/properties/created_by\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>User request object</property-description>").optional(),
  "created_by_id": z.string().optional(),
  "custom": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `custom` to the tool, first call the tool `expandSchema` with \"/properties/data/properties/custom\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>").optional(),
  "disabled": z.boolean().optional(),
  "frozen": z.boolean().describe("Freeze or unfreeze the channel").optional(),
  "invites": z.array(z.object({ "archived_at": z.string().datetime({ offset: true }).optional(), "ban_expires": z.string().datetime({ offset: true }).describe("Expiration date of the ban").optional(), "banned": z.boolean().describe("Whether member is banned this channel or not"), "channel_role": z.string().describe("Role of the member in the channel"), "created_at": z.string().datetime({ offset: true }).describe("Date/time of creation"), "custom": z.record(z.any()), "deleted_at": z.string().datetime({ offset: true }).optional(), "invite_accepted_at": z.string().datetime({ offset: true }).describe("Date when invite was accepted").optional(), "invite_rejected_at": z.string().datetime({ offset: true }).describe("Date when invite was rejected").optional(), "invited": z.boolean().describe("Whether member was invited or not").optional(), "is_moderator": z.boolean().describe("Whether member is channel moderator or not").optional(), "notifications_muted": z.boolean(), "pinned_at": z.string().datetime({ offset: true }).optional(), "role": z.enum(["member","moderator","admin","owner"]).describe("Permission level of the member in the channel (DEPRECATED: use channel_role instead)").optional(), "shadow_banned": z.boolean().describe("Whether member is shadow banned in this channel or not"), "status": z.string().optional(), "updated_at": z.string().datetime({ offset: true }).describe("Date/time of the last update"), "user": z.object({ "ban_expires": z.string().datetime({ offset: true }).describe("Date when ban expires").optional(), "banned": z.boolean().describe("Whether a user is banned or not"), "blocked_user_ids": z.array(z.string()), "created_at": z.string().datetime({ offset: true }).describe("Date/time of creation"), "custom": z.record(z.any()).describe("Custom data for this object"), "deactivated_at": z.string().datetime({ offset: true }).describe("Date of deactivation").optional(), "deleted_at": z.string().datetime({ offset: true }).describe("Date/time of deletion").optional(), "devices": z.array(z.object({ "created_at": z.string().datetime({ offset: true }).describe("Date/time of creation"), "disabled": z.boolean().describe("Whether device is disabled or not").optional(), "disabled_reason": z.string().describe("Reason explaining why device had been disabled").optional(), "id": z.string().describe("Device ID"), "push_provider": z.string().describe("Push provider"), "push_provider_name": z.string().describe("Push provider name").optional(), "user_id": z.string().describe("User ID"), "voip": z.boolean().describe("When true the token is for Apple VoIP push notifications").optional() }).nullable().describe("Response for Device")).describe("List of devices user is using").optional(), "id": z.string().describe("Unique user identifier"), "image": z.string().optional(), "invisible": z.boolean(), "language": z.string().describe("Preferred language of a user"), "last_active": z.string().datetime({ offset: true }).describe("Date of last activity").optional(), "name": z.string().describe("Optional name of user").optional(), "online": z.boolean().describe("Whether a user online or not"), "privacy_settings": z.object({ "read_receipts": z.object({ "enabled": z.boolean() }).optional(), "typing_indicators": z.object({ "enabled": z.boolean() }).optional() }).describe("User privacy settings").optional(), "push_notifications": z.object({ "disabled": z.boolean().optional(), "disabled_until": z.string().datetime({ offset: true }).optional() }).describe("User push notification settings").optional(), "revoke_tokens_issued_before": z.string().datetime({ offset: true }).describe("Revocation date for tokens").optional(), "role": z.string().describe("Determines the set of user permissions"), "shadow_banned": z.boolean().describe("Whether a user is shadow banned"), "teams": z.array(z.string()).describe("List of teams user is a part of"), "teams_role": z.record(z.string()).optional(), "updated_at": z.string().datetime({ offset: true }).describe("Date/time of the last update") }).describe("User response object").optional(), "user_id": z.string().optional() }).nullable()).optional(),
  "members": z.array(z.object({ "archived_at": z.string().datetime({ offset: true }).optional(), "ban_expires": z.string().datetime({ offset: true }).describe("Expiration date of the ban").optional(), "banned": z.boolean().describe("Whether member is banned this channel or not"), "channel_role": z.string().describe("Role of the member in the channel"), "created_at": z.string().datetime({ offset: true }).describe("Date/time of creation"), "custom": z.record(z.any()), "deleted_at": z.string().datetime({ offset: true }).optional(), "invite_accepted_at": z.string().datetime({ offset: true }).describe("Date when invite was accepted").optional(), "invite_rejected_at": z.string().datetime({ offset: true }).describe("Date when invite was rejected").optional(), "invited": z.boolean().describe("Whether member was invited or not").optional(), "is_moderator": z.boolean().describe("Whether member is channel moderator or not").optional(), "notifications_muted": z.boolean(), "pinned_at": z.string().datetime({ offset: true }).optional(), "role": z.enum(["member","moderator","admin","owner"]).describe("Permission level of the member in the channel (DEPRECATED: use channel_role instead)").optional(), "shadow_banned": z.boolean().describe("Whether member is shadow banned in this channel or not"), "status": z.string().optional(), "updated_at": z.string().datetime({ offset: true }).describe("Date/time of the last update"), "user": z.object({ "ban_expires": z.string().datetime({ offset: true }).describe("Date when ban expires").optional(), "banned": z.boolean().describe("Whether a user is banned or not"), "blocked_user_ids": z.array(z.string()), "created_at": z.string().datetime({ offset: true }).describe("Date/time of creation"), "custom": z.record(z.any()).describe("Custom data for this object"), "deactivated_at": z.string().datetime({ offset: true }).describe("Date of deactivation").optional(), "deleted_at": z.string().datetime({ offset: true }).describe("Date/time of deletion").optional(), "devices": z.array(z.object({ "created_at": z.string().datetime({ offset: true }).describe("Date/time of creation"), "disabled": z.boolean().describe("Whether device is disabled or not").optional(), "disabled_reason": z.string().describe("Reason explaining why device had been disabled").optional(), "id": z.string().describe("Device ID"), "push_provider": z.string().describe("Push provider"), "push_provider_name": z.string().describe("Push provider name").optional(), "user_id": z.string().describe("User ID"), "voip": z.boolean().describe("When true the token is for Apple VoIP push notifications").optional() }).nullable().describe("Response for Device")).describe("List of devices user is using").optional(), "id": z.string().describe("Unique user identifier"), "image": z.string().optional(), "invisible": z.boolean(), "language": z.string().describe("Preferred language of a user"), "last_active": z.string().datetime({ offset: true }).describe("Date of last activity").optional(), "name": z.string().describe("Optional name of user").optional(), "online": z.boolean().describe("Whether a user online or not"), "privacy_settings": z.object({ "read_receipts": z.object({ "enabled": z.boolean() }).optional(), "typing_indicators": z.object({ "enabled": z.boolean() }).optional() }).describe("User privacy settings").optional(), "push_notifications": z.object({ "disabled": z.boolean().optional(), "disabled_until": z.string().datetime({ offset: true }).optional() }).describe("User push notification settings").optional(), "revoke_tokens_issued_before": z.string().datetime({ offset: true }).describe("Revocation date for tokens").optional(), "role": z.string().describe("Determines the set of user permissions"), "shadow_banned": z.boolean().describe("Whether a user is shadow banned"), "teams": z.array(z.string()).describe("List of teams user is a part of"), "teams_role": z.record(z.string()).optional(), "updated_at": z.string().datetime({ offset: true }).describe("Date/time of the last update") }).describe("User response object").optional(), "user_id": z.string().optional() }).nullable()).optional(),
  "team": z.string().describe("Team the channel belongs to (if multi-tenant mode is enabled)").optional(),
  "truncated_by_id": z.string().optional()
}