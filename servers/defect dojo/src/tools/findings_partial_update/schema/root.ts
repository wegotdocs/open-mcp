import { z } from "zod"

export const inputParamsSchema = {
  "id": z.number().int().describe("A unique integer value identifying this finding."),
  "tags": z.array(z.string().min(1)).optional(),
  "push_to_jira": z.boolean().optional(),
  "vulnerability_ids": z.array(z.object({ "vulnerability_id": z.string().min(1).max(50) })).optional(),
  "reporter": z.number().int().optional(),
  "title": z.string().min(1).max(511).describe("A short description of the flaw.").optional(),
  "date": z.string().date().describe("The date the flaw was discovered.").optional(),
  "sla_start_date": z.string().date().nullable().describe("(readonly)The date used as start date for SLA calculation. Set by expiring risk acceptances. Empty by default, causing a fallback to 'date'.").optional(),
  "sla_expiration_date": z.string().date().nullable().describe("(readonly)The date SLA expires for this finding. Empty by default, causing a fallback to 'date'.").optional(),
  "cwe": z.number().int().gte(-2147483648).lte(2147483647).nullable().describe("The CWE number associated with this flaw.").optional(),
  "epss_score": z.number().gte(0).lte(1).nullable().describe("EPSS score for the CVE. Describes how likely it is the vulnerability will be exploited in the next 30 days.").optional(),
  "epss_percentile": z.number().gte(0).lte(1).nullable().describe("EPSS percentile for the CVE. Describes how many CVEs are scored at or below this one.").optional(),
  "known_exploited": z.boolean().describe("Whether this vulnerability is known to have been exploited in the wild.").optional(),
  "ransomware_used": z.boolean().describe("Whether this vulnerability is known to have been leveraged as part of a ransomware campaign.").optional(),
  "kev_date": z.string().date().nullable().describe("The date the vulnerability was added to the KEV catalog.").optional(),
  "cvssv3": z.string().min(1).max(117).nullable().describe("Common Vulnerability Scoring System version 3 (CVSSv3) score associated with this finding.").optional(),
  "cvssv3_score": z.number().gte(0).lte(10).nullable().describe("Numerical CVSSv3 score for the vulnerability. If the vector is given, the score is updated while saving the finding. The value must be between 0-10.").optional(),
  "severity": z.string().min(1).max(200).describe("The severity level of this flaw (Critical, High, Medium, Low, Info).").optional(),
  "description": z.string().min(1).describe("Longer more descriptive information about the flaw.").optional(),
  "mitigation": z.string().nullable().describe("Text describing how to best fix the flaw.").optional(),
  "impact": z.string().nullable().describe("Text describing the impact this flaw has on systems, products, enterprise, etc.").optional(),
  "steps_to_reproduce": z.string().nullable().describe("Text describing the steps that must be followed in order to reproduce the flaw / bug.").optional(),
  "severity_justification": z.string().nullable().describe("Text describing why a certain severity was associated with this flaw.").optional(),
  "references": z.string().nullable().describe("The external documentation available for this flaw.").optional(),
  "active": z.boolean().describe("Denotes if this flaw is active or not.").optional(),
  "verified": z.boolean().describe("Denotes if this flaw has been manually verified by the tester.").optional(),
  "false_p": z.boolean().describe("Denotes if this flaw has been deemed a false positive by the tester.").optional(),
  "duplicate": z.boolean().describe("Denotes if this flaw is a duplicate of other flaws reported.").optional(),
  "out_of_scope": z.boolean().describe("Denotes if this flaw falls outside the scope of the test and/or engagement.").optional(),
  "risk_accepted": z.boolean().describe("Denotes if this finding has been marked as an accepted risk.").optional(),
  "under_review": z.boolean().describe("Denotes is this flaw is currently being reviewed.").optional(),
  "under_defect_review": z.boolean().describe("Denotes if this finding is under defect review.").optional(),
  "is_mitigated": z.boolean().describe("Denotes if this flaw has been fixed.").optional(),
  "numerical_severity": z.string().min(1).max(4).describe("The numerical representation of the severity (S0, S1, S2, S3, S4).").optional(),
  "line": z.number().int().gte(-2147483648).lte(2147483647).nullable().describe("Source line number of the attack vector.").optional(),
  "file_path": z.string().max(4000).nullable().describe("Identified file(s) containing the flaw.").optional(),
  "component_name": z.string().max(500).nullable().describe("Name of the affected component (library name, part of a system, ...).").optional(),
  "component_version": z.string().max(100).nullable().describe("Version of the affected component.").optional(),
  "static_finding": z.boolean().describe("Flaw has been detected from a Static Application Security Testing tool (SAST).").optional(),
  "dynamic_finding": z.boolean().describe("Flaw has been detected from a Dynamic Application Security Testing tool (DAST).").optional(),
  "unique_id_from_tool": z.string().max(500).nullable().describe("Vulnerability technical id from the source tool. Allows to track unique vulnerabilities over time across subsequent scans.").optional(),
  "vuln_id_from_tool": z.string().max(500).nullable().describe("Non-unique technical id from the source tool associated with the vulnerability type.").optional(),
  "sast_source_object": z.string().max(500).nullable().describe("Source object (variable, function...) of the attack vector.").optional(),
  "sast_sink_object": z.string().max(500).nullable().describe("Sink object (variable, function...) of the attack vector.").optional(),
  "sast_source_line": z.number().int().gte(-2147483648).lte(2147483647).nullable().describe("Source line number of the attack vector.").optional(),
  "sast_source_file_path": z.string().max(4000).nullable().describe("Source file path of the attack vector.").optional(),
  "nb_occurences": z.number().int().gte(-2147483648).lte(2147483647).nullable().describe("Number of occurences in the source tool when several vulnerabilites were found and aggregated by the scanner.").optional(),
  "publish_date": z.string().date().nullable().describe("Date when this vulnerability was made publicly available.").optional(),
  "service": z.string().max(200).nullable().describe("A service is a self-contained piece of functionality within a Product. This is an optional field which is used in deduplication of findings when set.").optional(),
  "planned_remediation_date": z.string().date().nullable().describe("The date the flaw is expected to be remediated.").optional(),
  "planned_remediation_version": z.string().max(99).nullable().describe("The target version when the vulnerability should be fixed / remediated").optional(),
  "effort_for_fixing": z.string().max(99).nullable().describe("Effort for fixing / remediating the vulnerability (Low, Medium, High)").optional(),
  "review_requested_by": z.number().int().nullable().describe("Documents who requested a review for this finding.").optional(),
  "defect_review_requested_by": z.number().int().nullable().describe("Documents who requested a defect review for this flaw.").optional(),
  "sonarqube_issue": z.number().int().nullable().describe("The SonarQube issue associated with this finding.").optional(),
  "reviewers": z.array(z.number().int()).describe("Documents who reviewed the flaw.").optional()
}