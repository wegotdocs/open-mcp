import { z } from "zod"

export const inputParamsSchema = {
  "active": z.boolean().optional(),
  "component_name": z.string().optional(),
  "component_version": z.string().optional(),
  "created": z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5), z.literal(6), z.literal(7), z.literal(null)]).nullable().describe("The date the finding was created inside DefectDojo.\n\n* `None` - Any date\n* `1` - Today\n* `2` - Past 7 days\n* `3` - Past 30 days\n* `4` - Past 90 days\n* `5` - Current month\n* `6` - Current year\n* `7` - Past year").optional(),
  "cvssv3": z.string().optional(),
  "cvssv3_score": z.number().optional(),
  "cwe": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "date": z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5), z.literal(6), z.literal(7), z.literal(null)]).describe("The date the flaw was discovered.\n\n* `None` - Any date\n* `1` - Today\n* `2` - Past 7 days\n* `3` - Past 30 days\n* `4` - Past 90 days\n* `5` - Current month\n* `6` - Current year\n* `7` - Past year").optional(),
  "defect_review_requested_by": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "description": z.string().optional(),
  "discovered_after": z.string().date().optional(),
  "discovered_before": z.string().date().optional(),
  "discovered_on": z.string().date().optional(),
  "duplicate": z.boolean().optional(),
  "duplicate_finding": z.number().int().optional(),
  "dynamic_finding": z.boolean().optional(),
  "effort_for_fixing": z.string().optional(),
  "endpoints": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "epss_percentile_max": z.number().gte(0).lte(1).nullable().describe("The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.").optional(),
  "epss_percentile_min": z.number().gte(0).lte(1).nullable().describe("The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.").optional(),
  "epss_score_max": z.number().gte(0).lte(1).nullable().describe("The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.").optional(),
  "epss_score_min": z.number().gte(0).lte(1).nullable().describe("The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.").optional(),
  "false_p": z.boolean().optional(),
  "file_path": z.string().optional(),
  "finding_group": z.array(z.number()).describe("Multiple values may be separated by commas.").optional(),
  "found_by": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "has_jira": z.boolean().optional(),
  "has_tags": z.boolean().describe("Has tags").optional(),
  "hash_code": z.string().optional(),
  "id": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "impact": z.string().optional(),
  "inherited_tags": z.array(z.array(z.number().int())).describe("Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field").optional(),
  "is_mitigated": z.boolean().optional(),
  "jira_change": z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5), z.literal(6), z.literal(7), z.literal(null)]).nullable().describe("The date the linked Jira issue was last modified.\n\n* `None` - Any date\n* `1` - Today\n* `2` - Past 7 days\n* `3` - Past 30 days\n* `4` - Past 90 days\n* `5` - Current month\n* `6` - Current year\n* `7` - Past year").optional(),
  "jira_creation": z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5), z.literal(6), z.literal(7), z.literal(null)]).nullable().describe("The date a Jira issue was created from this finding.\n\n* `None` - Any date\n* `1` - Today\n* `2` - Past 7 days\n* `3` - Past 30 days\n* `4` - Past 90 days\n* `5` - Current month\n* `6` - Current year\n* `7` - Past year").optional(),
  "kev_date": z.string().date().optional(),
  "known_exploited": z.boolean().optional(),
  "last_reviewed": z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5), z.literal(6), z.literal(7), z.literal(null)]).nullable().describe("Provides the date the flaw was last 'touched' by a tester.\n\n* `None` - Any date\n* `1` - Today\n* `2` - Past 7 days\n* `3` - Past 30 days\n* `4` - Past 90 days\n* `5` - Current month\n* `6` - Current year\n* `7` - Past year").optional(),
  "last_reviewed_by": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "last_status_update": z.string().datetime({ offset: true }).optional(),
  "limit": z.number().int().describe("Number of results to return per page.").optional(),
  "mitigated": z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5), z.literal(6), z.literal(7), z.literal(null)]).nullable().describe("Denotes if this flaw has been fixed by storing the date it was fixed.\n\n* `None` - Any date\n* `1` - Today\n* `2` - Past 7 days\n* `3` - Past 30 days\n* `4` - Past 90 days\n* `5` - Current month\n* `6` - Current year\n* `7` - Past year").optional(),
  "mitigated_after": z.string().datetime({ offset: true }).describe("Mitigated After").optional(),
  "mitigated_before": z.string().datetime({ offset: true }).optional(),
  "mitigated_by": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "mitigated_on": z.string().datetime({ offset: true }).optional(),
  "mitigation": z.string().optional(),
  "nb_occurences": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "not_tag": z.string().describe("Not Tag name contains").optional(),
  "not_tags": z.array(z.string()).describe("Comma separated list of exact tags not present on model").optional(),
  "not_test__engagement__product__tags": z.array(z.string()).describe("Comma separated list of exact tags not present on product").optional(),
  "not_test__engagement__tags": z.array(z.string()).describe("Comma separated list of exact tags not present on engagement").optional(),
  "not_test__tags": z.array(z.string()).describe("Comma separated list of exact tags present on test").optional(),
  "numerical_severity": z.string().optional(),
  "o": z.array(z.enum(["-active","-component_name","-component_version","-created","-cwe","-date","-duplicate","-dynamic_finding","-false_p","-found_by","-id","-is_mitigated","-last_reviewed","-last_status_update","-numerical_severity","-out_of_scope","-reviewers","-severity","-static_finding","-test__engagement__product__name","-title","-under_defect_review","-under_review","-verified","active","component_name","component_version","created","cwe","date","duplicate","dynamic_finding","false_p","found_by","id","is_mitigated","last_reviewed","last_status_update","numerical_severity","out_of_scope","reviewers","severity","static_finding","test__engagement__product__name","title","under_defect_review","under_review","verified"])).describe("Ordering\n\n* `active` - Active\n* `-active` - Active (descending)\n* `component_name` - Component name\n* `-component_name` - Component name (descending)\n* `component_version` - Component version\n* `-component_version` - Component version (descending)\n* `created` - Created\n* `-created` - Created (descending)\n* `last_status_update` - Last status update\n* `-last_status_update` - Last status update (descending)\n* `last_reviewed` - Last reviewed\n* `-last_reviewed` - Last reviewed (descending)\n* `cwe` - Cwe\n* `-cwe` - Cwe (descending)\n* `date` - Date\n* `-date` - Date (descending)\n* `duplicate` - Duplicate\n* `-duplicate` - Duplicate (descending)\n* `dynamic_finding` - Dynamic finding\n* `-dynamic_finding` - Dynamic finding (descending)\n* `false_p` - False p\n* `-false_p` - False p (descending)\n* `found_by` - Found by\n* `-found_by` - Found by (descending)\n* `id` - Id\n* `-id` - Id (descending)\n* `is_mitigated` - Is mitigated\n* `-is_mitigated` - Is mitigated (descending)\n* `numerical_severity` - Numerical severity\n* `-numerical_severity` - Numerical severity (descending)\n* `out_of_scope` - Out of scope\n* `-out_of_scope` - Out of scope (descending)\n* `severity` - Severity\n* `-severity` - Severity (descending)\n* `reviewers` - Reviewers\n* `-reviewers` - Reviewers (descending)\n* `static_finding` - Static finding\n* `-static_finding` - Static finding (descending)\n* `test__engagement__product__name` - Test  engagement  product  name\n* `-test__engagement__product__name` - Test  engagement  product  name (descending)\n* `title` - Title\n* `-title` - Title (descending)\n* `under_defect_review` - Under defect review\n* `-under_defect_review` - Under defect review (descending)\n* `under_review` - Under review\n* `-under_review` - Under review (descending)\n* `verified` - Verified\n* `-verified` - Verified (descending)").optional(),
  "offset": z.number().int().describe("The initial index from which to return the results.").optional(),
  "out_of_scope": z.boolean().optional(),
  "outside_of_sla": z.number().optional(),
  "param": z.string().optional(),
  "payload": z.string().optional(),
  "planned_remediation_date": z.string().date().optional(),
  "planned_remediation_version": z.string().optional(),
  "prefetch": z.array(z.enum(["auth_issues","author_issues","config_issues","crypto_issues","data_issues","defect_review_requested_by","duplicate_finding","endpoint_set","endpoints","files","finding_group_set","found_by","last_reviewed_by","mitigated_by","notes","other_issues","reporter","review_requested_by","reviewers","risk_acceptance_set","sensitive_issues","session_issues","sonarqube_issue","test","test_import_set"])).describe("List of fields for which to prefetch model instances and add those to the response").optional(),
  "product_lifecycle": z.string().describe("Comma separated list of exact product lifecycles").optional(),
  "product_name": z.string().describe("exact product name").optional(),
  "product_name_contains": z.string().describe("exact product name").optional(),
  "publish_date": z.string().date().optional(),
  "ransomware_used": z.boolean().optional(),
  "references": z.string().optional(),
  "related_fields": z.boolean().describe("Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)").optional(),
  "reporter": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "review_requested_by": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "reviewers": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "risk_acceptance": z.number().optional(),
  "risk_accepted": z.boolean().optional(),
  "sast_sink_object": z.string().optional(),
  "sast_source_file_path": z.string().optional(),
  "sast_source_line": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "sast_source_object": z.string().optional(),
  "scanner_confidence": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "service": z.string().optional(),
  "severity": z.string().optional(),
  "severity_justification": z.string().optional(),
  "sla_expiration_date": z.string().date().optional(),
  "sla_start_date": z.string().date().optional(),
  "sonarqube_issue": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "static_finding": z.boolean().optional(),
  "steps_to_reproduce": z.string().optional(),
  "tag": z.string().describe("Tag name contains").optional(),
  "tags": z.array(z.string()).describe("Comma separated list of exact tags (uses OR for multiple values)").optional(),
  "tags__and": z.array(z.string()).describe("Comma separated list of exact tags to match with an AND expression").optional(),
  "test": z.number().int().optional(),
  "test__engagement": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "test__engagement__product": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "test__engagement__product__prod_type": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "test__engagement__product__tags": z.array(z.string()).describe("Comma separated list of exact tags present on product (uses OR for multiple values)").optional(),
  "test__engagement__product__tags__and": z.array(z.string()).describe("Comma separated list of exact tags to match with an AND expression present on product").optional(),
  "test__engagement__tags": z.array(z.string()).describe("Comma separated list of exact tags present on engagement (uses OR for multiple values)").optional(),
  "test__engagement__tags__and": z.array(z.string()).describe("Comma separated list of exact tags to match with an AND expression present on engagement").optional(),
  "test__tags": z.array(z.string()).describe("Comma separated list of exact tags present on test (uses OR for multiple values)").optional(),
  "test__tags__and": z.array(z.string()).describe("Comma separated list of exact tags to match with an AND expression present on test").optional(),
  "test__test_type": z.array(z.number().int()).describe("Multiple values may be separated by commas.").optional(),
  "title": z.string().optional(),
  "under_defect_review": z.boolean().optional(),
  "under_review": z.boolean().optional(),
  "unique_id_from_tool": z.string().optional(),
  "verified": z.boolean().optional(),
  "vuln_id_from_tool": z.string().optional(),
  "vulnerability_id": z.string().optional()
}