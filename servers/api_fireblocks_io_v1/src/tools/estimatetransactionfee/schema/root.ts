import { z } from "zod"

export const inputParamsSchema = {
  "operation": z.enum(["TRANSFER","BURN","CONTRACT_CALL","PROGRAM_CALL","MINT","RAW","TYPED_MESSAGE","APPROVE","ENABLE_ASSET"]).describe("* `TRANSFER` - The default value for an operation. Transfers funds from one account to another. UTXO blockchains allow multi-input and multi-output transfers. All other blockchains allow transfers with one source address and one destination address.\n* `MINT` - Mints new tokens. Supported for Stellar, Ripple and EVM-based blockchains.\n* `BURN` - Burns tokens. Supported for Stellar, Ripple and EVM-based blockchains.\n* `CONTRACT_CALL` - Calls a smart contract method for web3 operations on any EVM blockchain. The Fireblocks [development libraries](https://developers.fireblocks.com/docs/ethereum-development#convenience-libraries) are recommended for building contract call transactions.\n* `PROGRAM_CALL` - Execute multiple instructions on Solana blockchain. The @solana/web3.js library is recommended for building program call transactions. Currently in beta and disabled\n* `TYPED_MESSAGE` - An off-chain message in either Ethereum Personal Message or EIP712 format. Use it to sign specific readable messages that are not actual transactions. [Learn more about typed messages](https://developers.fireblocks.com/docs/typed-message-signing).\n* `RAW` - An off-chain message with no predefined format. Use it to sign any message with your private key, including protocols such as blockchains and custom transaction types that are not natively supported by Fireblocks. [Learn more about raw signing transactions.](https://developers.fireblocks.com/docs/raw-message-signing)\n* `APPROVE` - Enables the approve function for a smart contract or wallet to  withdraw from a designated wallet. [Learn more](https://support.fireblocks.io/hc/en-us/articles/4404616097426-Amount-Cap-for-Approve-transactions).\n* `ENABLE_ASSET` - Algorand, DigitalBits, Solana, and Stellar require an on-chain transaction to create an asset wallet and enable the deposit address. This transaction is automatically created when adding assets on these blockchains at a vault account.\n").optional(),
  "note": z.string().describe("Custom note, not sent to the blockchain, to describe the transaction at your Fireblocks workspace.").optional(),
  "externalTxId": z.string().describe("An optional but highly recommended parameter. Fireblocks will reject future transactions with same ID. \nYou should set this to a unique ID representing the transaction, to avoid submitting the same transaction twice. This helps with cases where submitting the transaction responds with an error code due to Internet interruptions, but the transaction was actually sent and processed. To validate whether a transaction has been processed, [Find a specific transaction by external transaction ID](https://developers.fireblocks.com/reference/get_transactions-external-tx-id-externaltxid).\nThere is no specific format required for this parameter.").optional(),
  "assetId": z.string().describe("The ID of the asset to transfer, for `TRANSFER`, `MINT` or `BURN` operations. [See the list of supported assets and their IDs on Fireblocks.](https://developers.fireblocks.com/reference/get_supported-assets)").optional(),
  "source": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `source` to the tool, first call the tool `expandSchema` with \"/properties/source\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The source of the transaction.</property-description>").optional(),
  "destination": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `destination` to the tool, first call the tool `expandSchema` with \"/properties/destination\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The destination of the transaction.</property-description>").optional(),
  "destinations": z.array(z.object({ "amount": z.string().optional(), "destination": z.object({ "type": z.enum(["VAULT_ACCOUNT","EXCHANGE_ACCOUNT","INTERNAL_WALLET","EXTERNAL_WALLET","CONTRACT","NETWORK_CONNECTION","FIAT_ACCOUNT","COMPOUND","GAS_STATION","ONE_TIME_ADDRESS","UNKNOWN","END_USER_WALLET","PROGRAM_CALL","MULTI_DESTINATION"]), "subType": z.enum(["BINANCE","BINANCEUS","BITFINEX","BITHUMB","BITMEX","BITSO","BITSTAMP","BITTREX","BLINC","BYBIT","CIRCLE","COINBASEEXCHANGE","COINBASEPRO","COINMETRO","COINSPRO","CRYPTOCOM","DERIBIT","GEMINI","HITBTC","HUOBI","INDEPENDENTRESERVE","KORBIT","KRAKEN","KRAKENINTL","KUCOIN","LIQUID","OKCOIN","OKEX","PAXOS","POLONIEX","External","Internal"]).optional(), "id": z.string().optional(), "name": z.string().optional(), "walletId": z.string().uuid().optional(), "oneTimeAddress": z.object({ "address": z.string(), "tag": z.string().optional() }).optional(), "isCollateral": z.boolean().describe("indicate if the destination is collateral account").optional() }).describe("The destination of the transaction.").optional() })).describe("For UTXO based blockchains, you can send a single transaction to multiple destinations.").optional(),
  "amount": z.string().describe("Numeric string (recommended)").describe("For `TRANSFER` operations, the requested amount to transfer, in the asset’s unit. Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated.").optional(),
  "treatAsGrossAmount": z.boolean().describe("\"When set to `true`, the fee will be deducted from the requested amount.\"\n\n**Note**: This parameter can only be considered if a transaction’s asset is a base asset, such as ETH or MATIC. If the asset can’t be used for transaction fees, like USDC, this parameter is ignored and the fee is deducted from the relevant base asset wallet in the source account.").optional(),
  "forceSweep": z.boolean().describe("For Polkadot, Kusama and Westend transactions only. When set to true, Fireblocks will empty the asset wallet.\n\n   **Note:** If set to true when the source account is exactly 1 DOT, the transaction will fail. Any amount more or less than 1 DOT succeeds. This is a Polkadot blockchain limitation.").optional(),
  "feeLevel": z.enum(["LOW","MEDIUM","HIGH"]).describe("For UTXO or EVM-based blockchains only. Defines the blockchain fee level which will be payed for the transaction. Alternatively, specific fee estimation parameters exist below.").optional(),
  "fee": z.string().describe("Numeric string (recommended)").describe("For UTXO-based blockchains, the fee per bytes in the asset’s smallest unit (Satoshi, Latoshi, etc.).  For Ripple, the fee for the transaction. Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated.").optional(),
  "priorityFee": z.string().describe("Numeric string (recommended)").describe("For Ethereum-based blockchains only, the fee for EIP-1559 transaction pricing mechanism. Value is in Gwei.  Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated.").optional(),
  "failOnLowFee": z.boolean().describe("When set to `true`, in case the current `MEDIUM` fee level is higher than the one specified in the transaction, the transaction will fail to avoid getting stuck with no confirmations.").optional(),
  "maxFee": z.string().describe("The maximum fee (gas price or fee per byte) that should be payed for the transaction.  In case the current value of the requested `feeLevel` is higher than this requested maximum fee.  Represented by a numeric string for accurate precision.").optional(),
  "maxTotalFee": z.string().describe("For BTC-based blockchains only. The maximum fee (in the units of the fee-paying asset) that should be paid for the transaction.").optional(),
  "gasLimit": z.string().describe("Numeric string (recommended)").describe("For EVM-based blockchains only. Units of gas required to process the transaction. Note: Only two of the three arguments can be specified in a single transaction: `gasLimit`, `gasPrice` and `networkFee`. Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated.").optional(),
  "gasPrice": z.string().describe("Numeric string (recommended)").describe("For non-EIP-1559, EVM-based transactions. Price per gas unit (in Ethereum this is specified in Gwei).  Note: Only two of the three arguments can be specified in a single transaction: `gasLimit`, `gasPrice` and `networkFee`. Fireblocks recommends using a numeric string for accurate precision.  Although a number input exists, it is deprecated.").optional(),
  "networkFee": z.string().describe("Numeric string (recommended)").describe("For EVM-based blockchains only. The total transaction fee in the blockchain’s largest unit. Note: Only two of the three arguments can be specified in a single transaction: `gasLimit`, `gasPrice` and `networkFee`. Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated. - The transaction blockchain fee.\n- For Ethereum, you can't pass gasPrice, gasLimit and networkFee all together.\n- A numeric value representation is required.").optional(),
  "replaceTxByHash": z.string().describe("For EVM-based blockchains only. In case a transaction is stuck, specify the hash of the stuck transaction to replace it by this transaction with a higher fee, or to replace it with this transaction with a zero fee and drop it from the blockchain.").optional(),
  "extraParameters": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `extraParameters` to the tool, first call the tool `expandSchema` with \"/properties/extraParameters\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>Additional protocol / operation specific key-value parameters:\n\nFor UTXO-based blockchain input selection, add the key `inputsSelection` with the value set the [input selection structure.](https://developers.fireblocks.com/reference/transaction-objects#inputsselection) The inputs can be retrieved from the [Retrieve Unspent Inputs endpoint.](https://developers.fireblocks.com/reference/get_vault-accounts-vaultaccountid-assetid-unspent-inputs)\n\nFor `RAW` operations, add the key `rawMessageData` with the value set to the [raw message data structure.](https://developers.fireblocks.com/reference/raw-signing-objects#rawmessagedata)\n\nFor `CONTRACT_CALL` operations, add the key `contractCallData` with the value set to the Ethereum smart contract Application Binary Interface (ABI) payload. The Fireblocks [development libraries](https://developers.fireblocks.com/docs/ethereum-development#convenience-libraries) are recommended for building contract call transactions.\n</property-description>").optional(),
  "customerRefId": z.string().describe("The ID for AML providers to associate the owner of funds with transactions.").optional(),
  "travelRuleMessage": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `travelRuleMessage` to the tool, first call the tool `expandSchema` with \"/properties/travelRuleMessage\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>").optional(),
  "useGasless": z.boolean().describe("- Override the default gasless configuration by sending true\\false").optional(),
  "Idempotency-Key": z.string().describe("A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.").optional()
}