import { z } from "zod"

export const inputParamsSchema = {
  "messages": z.array(z.object({ "preHash": z.object({ "content": z.string().describe("The prehashed content to sign on in hex representation."), "hashAlgorithm": z.enum(["SHA256","KECCAK256","SHA3","BLAKE2","DOUBLE_SHA256"]).describe("The hashing algorithm to use in order to hash the content before the signature process") }).describe("The prehash object for ECDSA RAW signing requests. \nThe prehash object contains the content to sign (the actual message in hex representation) and the hashing algorithm to use before signing.\n").optional(), "content": z.string().describe("Content to sign on. \nShould be 32 bytes long for ECDSA (hash of the actual message to sign) or any length for EdDSA as prehashing is not required.\n"), "bip44addressIndex": z.number().int().describe("BIP44 address index").optional(), "bip44change": z.number().describe("BIP44 change index").optional(), "derivationPath": z.array(z.number()).describe("BIP44 full derivation path").optional(), "type": z.enum(["EIP191","EIP712","TIP191","BTC_MESSAGE"]).describe("Typed Message Signing - message type.\n\n- EIP191 & EIP712: for ETH and all EVM based assets typed message signing\n- TIP191: For Tron (TRX) typed message signing\n- BTC_MESSAGE: For Bitcoin (BTC) typed message signing\n").optional() })).optional(),
  "algorithm": z.enum(["MPC_ECDSA_SECP256K1","MPC_ECDSA_SECP256R1","MPC_EDDSA_ED25519"]).optional()
}