import { z } from "zod"

export const inputParamsSchema = {
  "rules": z.array(z.object({ "operators": z.object({ "wildcard": z.literal("*").describe("If used then this property should appear as the only child property\n* \"*\" - All users are allowed\n").optional(), "users": z.array(z.string()).describe("Set of users ids").optional(), "usersGroups": z.array(z.string()).describe("Set of group ids").optional(), "services": z.array(z.string()).describe("set of services to initiate transactions").optional() }).describe("Defines users/groups who can initiate the type of transaction to which the rule applies.").optional(), "transactionType": z.enum(["TRANSFER","CONTRACT_CALL","APPROVE","MINT","BURN","SUPPLY","REDEEM","STAKE","RAW","TYPED_MESSAGE","PROGRAM_CALL"]).describe("Defines the type of transaction to which the rule applies.\n  * TRANSFER - Default. Transfers funds from one account to another\n  * CONTRACT_CALL - Calls a smart contract, mainly for DeFi operations.\n  * APPROVE - Allows a smart contract to withdraw from a designated wallet.\n  * MINT - Perform a mint operation (increase supply) on a supported token\n  * BURN - Perform a burn operation (reduce supply) on a supported token\n  * SUPPLY - Use for DeFi to lend assets\n  * REDEEM - Use for DeFi to get lending back\n  * STAKE - Allows you to allocate and lock certain assets for earning staking rewards.\n  * RAW - An off-chain message with no predefined format, use it to sign any message with your private key.\n  * TYPED_MESSAGE - An off-chain message type that follows a predefined format, used to sign specific messages that are not actual transactions.\n  * PROGRAM_CALL - In Solana refers to invoking on-chain programs (smart contracts) to execute transactions and interact with the blockchain.\n").optional(), "designatedSigners": z.object({ "users": z.array(z.string()).describe("Set of users ids").optional(), "usersGroups": z.array(z.string()).describe("Set of group ids").optional() }).describe("Set of ids representing the users who signs transactions that match a specific rule").optional(), "type": z.literal("TRANSFER").describe("Policy rule type"), "action": z.enum(["ALLOW","BLOCK","2-TIER"]).describe("Defines what occurs when a transaction meets the rule's criteria\n* ALLOW - The transaction goes through and can be signed without requiring additional approvals\n* BLOCK - The transaction is automatically blocked\n* 2-TIER - Only these users or user groups can approve \n           If any of them reject the transaction before the required approval threshold is met, the transaction doesn't go through\n           The list of entities are set is \"authorizationGroups\" field\n"), "asset": z.string().describe("Defines the type of asset being transacted, options are\n* \"*\" - All assets\n* Specific asset\n"), "src": z.object({ "ids": z.array(z.array(z.union([z.string().describe("Defines the account id, options are\n* \"*\" - All accounts\n* Specific account id\n"), z.enum(["EXCHANGE","UNMANAGED","VAULT","NETWORK_CONNECTION","COMPOUND","FIAT_ACCOUNT","ONE_TIME_ADDRESS","*"]).describe("* EXCHANGE - A third-party exchange account connected to your workspace\n* UNMANAGED - A unmanaged wallet outside of Fireblocks workspace\n* VAULT - An account in your Fireblocks Vault\n* NETWORK_CONNECTION - A connection in your Fireblocks network\n* COMPOUND - (deprecated) An asset retrieved by using the Compound DeFI protocol\n* FIAT_ACCOUNT - A third-party fiat account connected to your workspace\n* ONE_TIME_ADDRESS - A non-whitelisted asset from your Fireblocks Workspace\n* \"*\" - All types\n"), z.enum(["EXTERNAL","INTERNAL","CONTRACT","EXCHANGETEST","*"]).describe("* EXTERNAL - A whitelisted wallet assigned as external is typically used for addresses managed by your clients and counterparties\n* INTERNAL - A whitelisted wallet assigned as internal, is typically used for addresses that you control outside of your Fireblocks workspace\n* CONTRACT - A whitelisted wallet assigned as contract is for identifying and managing external smart contracts\n* EXCHANGETEST - Exchanges which operate only on testnet assets\n* \"*\" - All subtypes\n")])).min(1).max(3).describe("Defines source or destination component, options are:\n* id only\n* id and type - first item in the array MUST be id.\n* id, type and subtype - first item in the array MUST be id and second item MUST be type.\n")).describe("A set of ids in a tuple format").optional() }).describe("Defines source accounts the rule allows transfers to originate from").optional(), "dst": z.object({ "ids": z.array(z.array(z.union([z.string().describe("Defines the account id, options are\n* \"*\" - All accounts\n* Specific account id\n"), z.enum(["EXCHANGE","UNMANAGED","VAULT","NETWORK_CONNECTION","COMPOUND","FIAT_ACCOUNT","ONE_TIME_ADDRESS","*"]).describe("* EXCHANGE - A third-party exchange account connected to your workspace\n* UNMANAGED - A unmanaged wallet outside of Fireblocks workspace\n* VAULT - An account in your Fireblocks Vault\n* NETWORK_CONNECTION - A connection in your Fireblocks network\n* COMPOUND - (deprecated) An asset retrieved by using the Compound DeFI protocol\n* FIAT_ACCOUNT - A third-party fiat account connected to your workspace\n* ONE_TIME_ADDRESS - A non-whitelisted asset from your Fireblocks Workspace\n* \"*\" - All types\n"), z.enum(["EXTERNAL","INTERNAL","CONTRACT","EXCHANGETEST","*"]).describe("* EXTERNAL - A whitelisted wallet assigned as external is typically used for addresses managed by your clients and counterparties\n* INTERNAL - A whitelisted wallet assigned as internal, is typically used for addresses that you control outside of your Fireblocks workspace\n* CONTRACT - A whitelisted wallet assigned as contract is for identifying and managing external smart contracts\n* EXCHANGETEST - Exchanges which operate only on testnet assets\n* \"*\" - All subtypes\n")])).min(1).max(3).describe("Defines source or destination component, options are:\n* id only\n* id and type - first item in the array MUST be id.\n* id, type and subtype - first item in the array MUST be id and second item MUST be type.\n")).describe("A set of ids in a tuple format").optional() }).describe("Defines the destination accounts the rule allows transfers to").optional(), "dstAddressType": z.enum(["WHITELISTED","ONE_TIME","*"]).describe("Defines whether the destination to which you are sending funds must be whitelisted, to allow one-time transfers to non-whitelisted external addresses, or both.\nBy default, you can only transfer to an external address after itâ€™s whitelisted.\n  * WHITELISTED - Can only be sent to whitelisted addresses.\n  * ONE_TIME - Can only be sent to non-whitelisted external addresses.\n  * \"*\" - can be sent to whitelisted addresses or non-whitelisted external\n").optional(), "amountCurrency": z.enum(["USD","EUR","NATIVE"]).describe("* USD - Limits the amount of any asset users can transfer based on the USD equivalent of the asset.\n* EUR - Limits the amount of any asset users can transfer based on the EURO equivalent of the asset.\n* NATIVE - Limits the amount of an asset a user can transfer when using a specific asset.\n"), "amountScope": z.enum(["SINGLE_TX","TIMEFRAME"]).describe("* SINGLE_TX - limit applies to a single transaction\n* TIMEFRAME - limit applies to all transactions within the defined time period\n"), "amount": z.union([z.string().describe("Numeric string (recommended)"), z.number().describe("Number (deprecated)")]).describe("Defines the value a transaction must exceed for the rule to apply to it (according to the amountCurrency field)"), "periodSec": z.number().describe("Time period in seconds applied by the amountScope field to accumulate transferred amounts in transactions that match the rule, until the total exceeds the value you specify under Minimum.\nWhen the specified amount is reached within that period, whether by one or many transactions, further transactions in that period either fail or require more approvals.\n"), "authorizationGroups": z.object({ "logic": z.enum(["AND","OR"]).describe("* AND - requires approval of all authorization groups\n* OR - requires approval of at least one of the authorization groups\n").optional(), "allowOperatorAsAuthorizer": z.boolean().describe("Defines whether the user who initiates a transaction can approve their own transaction and count toward the approval threshold for their transaction").optional(), "groups": z.array(z.object({ "users": z.array(z.string()).describe("User ids").optional(), "usersGroups": z.array(z.string()).describe("Group ids").optional(), "th": z.number().describe("Represents the min amount of entities which are required to approve the transaction, default is 1.").optional() })).describe("Groups of entities which can approve the transaction").optional() }).describe("Defines the transaction approval terms").optional(), "amountAggregation": z.object({ "operators": z.enum(["PER_SINGLE_MATCH","ACROSS_ALL_MATCHES"]).describe("* PER_SINGLE_MATCH - Apply the limit to each listed entity\n* ACROSS_ALL_MATCHES - Apply the limit to the sum of all listed entities\n").optional(), "srcTransferPeers": z.enum(["PER_SINGLE_MATCH","ACROSS_ALL_MATCHES"]).describe("* PER_SINGLE_MATCH - Apply the limit to each listed entity\n* ACROSS_ALL_MATCHES - Apply the limit to the sum of all listed entities\n").optional(), "dstTransferPeers": z.enum(["PER_SINGLE_MATCH","ACROSS_ALL_MATCHES"]).describe("* PER_SINGLE_MATCH - Apply the limit to each listed entity\n* ACROSS_ALL_MATCHES - Apply the limit to the sum of all listed entities\n").optional() }).describe("Defines the method by which the Policy Engine calculates accumulation.\nIt uses the Initiator, Source, and Destination to calculate accumulation toward the value under Minimum, for the time under Time Period.\n").optional(), "rawMessageSigning": z.object({ "algorithm": z.string().optional(), "derivationPath": z.object({ "path": z.array(z.number()).optional() }).optional() }).describe("Raw message signing configuration").optional(), "applyForApprove": z.boolean().describe("Applying this rule over APPROVE type transactions (can only be enabled when rule's transaction type is TRANSFER)").optional(), "applyForTypedMessage": z.boolean().describe("Applying this rule over TYPED_MESSAGE type transactions (can only be enabled when rule's transaction type is CONTRACT_CALL)").optional(), "externalDescriptor": z.string().describe("A unique id identifying the rule").optional() }).describe("Policy rule which is enforced on transactions")).describe("Policy rules").optional(),
  "Idempotency-Key": z.string().describe("A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.").optional()
}