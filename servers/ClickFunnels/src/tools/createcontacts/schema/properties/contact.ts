import { z } from "zod"

export const inputParamsSchema = {
  "email_address": z.union([z.string().describe("Email address"), z.null().describe("Email address")]).describe("Email address").optional(),
  "first_name": z.union([z.string().describe("First name"), z.null().describe("First name")]).describe("First name").optional(),
  "last_name": z.union([z.string().describe("Last name"), z.null().describe("Last name")]).describe("Last name").optional(),
  "phone_number": z.union([z.string().describe("Phone number"), z.null().describe("Phone number")]).describe("Phone number").optional(),
  "time_zone": z.union([z.string().describe("The human-readable time zone, usually set dynamically by the app for the contact, for example, during opt-in.\nRead more about time zones and how to map them back to the TZ standard in [our Time Zones guide.](https://dash.readme.com/project/cf2/v2/docs/timezones).\n"), z.null().describe("The human-readable time zone, usually set dynamically by the app for the contact, for example, during opt-in.\nRead more about time zones and how to map them back to the TZ standard in [our Time Zones guide.](https://dash.readme.com/project/cf2/v2/docs/timezones).\n")]).describe("The human-readable time zone, usually set dynamically by the app for the contact, for example, during opt-in.\nRead more about time zones and how to map them back to the TZ standard in [our Time Zones guide.](https://dash.readme.com/project/cf2/v2/docs/timezones).\n").optional(),
  "fb_url": z.union([z.string().describe("Facebook URL"), z.null().describe("Facebook URL")]).describe("Facebook URL").optional(),
  "twitter_url": z.union([z.string().describe("Twitter URL"), z.null().describe("Twitter URL")]).describe("Twitter URL").optional(),
  "instagram_url": z.union([z.string().describe("Instagram URL"), z.null().describe("Instagram URL")]).describe("Instagram URL").optional(),
  "linkedin_url": z.union([z.string().describe("Linkedin URL"), z.null().describe("Linkedin URL")]).describe("Linkedin URL").optional(),
  "website_url": z.union([z.string().describe("Website URL"), z.null().describe("Website URL")]).describe("Website URL").optional(),
  "tag_ids": z.array(z.number().int()).describe("Contact Tag IDs. Any valid array, empty or with valid tags will overwrite existing values. To avoid losing existing tags first use the Fetch Contact endpoint, then be sure to include the existing tags in your payload along with any new addition(s).").optional(),
  "custom_attributes": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `custom_attributes` to the tool, first call the tool `expandSchema` with \"/properties/contact/properties/custom_attributes\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>Custom attributes are usually added in ClickFunnels to a contact when they submit forms that contain custom contact attributes. Here you can directly create them during contact modification.\n\nCustom attributes are provided as key-value pairs:\nA key that does not exist, will create a new custom contact attribute.\nA key that already exists, will update the value of an existing custom contact attribute.\n\nEmpty or null values, will set the custom attribute values to empty strings. A key that has special characters or spaces will be automatically converted to `snake_case` (For example, 'Favorite Food! ðŸ¥‘' will be converted to 'favorite_food').\n\nEmpty keys will trigger a bad request response. Also, non-object inputs for custom_attributes (e.g. an array or string), it will be ignored.\nKeys that are default properties on the Contact resource or variations of it will result in an error. E.g., 'first_name', 'First Name',  etc. are not valid inputs.\n</property-description>").optional()
}