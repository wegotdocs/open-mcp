import { z } from "zod"

export const inputParams = {
  "control_plane": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `control_plane` to the tool, first call the tool `expandSchema` with \"/properties/control_plane\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>Defines settings for the Kubernetes control plane, including High Availability (HA) and an IP-based Access Control List (ACL) for the control plane components.</property-description>").optional(),
  "k8s_version": z.string().describe("__Filterable__ The desired Kubernetes version for this Kubernetes cluster in the format of &lt;major&gt;.&lt;minor&gt;, and the latest supported patch version will be deployed."),
  "label": z.string().min(1).max(32).describe("__Filterable__ This Kubernetes cluster's unique label for display purposes only. Labels have the following constraints:\n\n  - UTF-8 characters will be returned by the API using escape sequences of their Unicode code points. For example, the Japanese character _か_ is 3 bytes in UTF-8 (`0xE382AB`). Its Unicode code point is 2 bytes (`0x30AB`). APIv4 supports this character and the API will return it as the escape sequence using six 1 byte characters which represent 2 bytes of Unicode code point (`\"\\u30ab\"`).\n\n  - 4 byte UTF-8 characters are not supported.\n\n  - If the label is entirely composed of UTF-8 characters, the API response will return the code points using up to 193 1 byte characters."),
  "node_pools": z.array(z.object({ "autoscaler": z.object({ "enabled": z.boolean().describe("Whether automatic scaling is enabled for this node pool. Defaults to `false`.").optional(), "max": z.number().int().gte(1).lte(100).describe("The maximum number of nodes to automatically scale to. Defaults to the value provided by the `count` field.").optional(), "min": z.number().int().gte(1).lte(100).describe("The minimum number of nodes to automatically scale to. Defaults to the node pool's `count`.").optional() }).strict().describe("When enabled, the number of nodes automatically scales within the defined minimum and maximum values. When making a request, `max` and `min` require each other.").optional(), "count": z.number().int().gte(1).lte(100).describe("The number of nodes in the Node Pool."), "disks": z.array(z.object({ "size": z.number().int().describe("The size of this custom disk partition in MB. The size of this disk partition can't exceed the capacity of the node's plan type.").optional(), "type": z.enum(["raw","ext4"]).describe("This custom disk partition's filesystem type.").optional() }).strict().describe("The values to assign to each partition in this Node Pool's custom disk layout.")).describe("This node pool's custom disk layout. Each item in this array will create a new disk partition for each node in this node pool.\n\n> 📘\n>\n> Omit this field, except for special use cases. The disks specified here are partitions in _addition_ to the primary partition and reduce the size of the primary partition. This can lead to stability problems for the node.\n\n  - The custom disk layout is applied to each node in this node pool.\n\n  - The maximum number of custom disk partitions that can be configured is 7.\n\n  - Once the requested disk partitions are allocated, the remaining disk space is allocated to the node's boot disk.\n\n  - A node pool's custom disk layout is immutable over the lifetime of the node pool.").optional(), "labels": z.record(z.string().regex(new RegExp("^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?")).min(0).max(63)).describe("Key-value pairs added as labels to nodes in the node pool. Labels help classify your nodes and easily select subsets of objects. To learn more, review [Add Labels and Taints to your LKE node pools](https://www.linode.com/docs/products/compute/kubernetes/guides/deploy-and-manage-cluster-with-the-linode-api/#add-labels-and-taints-to-your-lke-node-pools).\n\n**Label key:**\n\n- A key can contain alphanumeric characters, dashes (`-`), underscores (`_`), or dots (`.`). Start and end it with an alphanumeric character.\n\n- If the key begins with a DNS subdomain prefix followed by a single slash, for example `example.com/my-app`, the maximum total length of the label key is 128 characters. Domain labels can be up to 62 characters after the '/'. The prefix needs to adhere to [RFC 1123](https://datatracker.ietf.org/doc/html/rfc1123) DNS subdomain restrictions.\n\n- If the key doesn't begin with a DNS subdomain prefix, the maximum key length is 63 characters.\n\nSpecifying an empty object removes all previously set labels.\n\n**Label value:**\n\n- The label's value can contain alphanumeric characters, dashes (`-`), underscores (`_`), or dots (`.`). Start and end it with an alphanumeric character.\n\n- Can be specified as an empty string value with `\"\"`.").optional(), "tags": z.array(z.string()).describe("__Filterable__ An array of tags applied to this object. Tags are for organizational purposes only.").optional(), "taints": z.array(z.object({ "effect": z.enum(["NoSchedule","PreferNoSchedule","NoExecute"]).describe("The Kubernetes taint effect. For `NoSchedule`, `PreferNoSchedule` and `NoExecute` descriptions, see [Kubernetes Taints and Tolerations](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/)."), "key": z.string().regex(new RegExp("^([A-Za-z0-9][-A-Za-z0-9_.]*)?(\\/)?([A-Za-z0-9][-A-Za-z0-9_.]{1,63})?$")).min(1).max(63).describe("The Kubernetes taint key.\n\n- A key can contain alphanumeric characters, dashes (`-`), underscores (`_`), or dots (`.`). Start and end it with an alphanumeric character.\n\n- If the key begins with a DNS subdomain prefix followed by a single slash, for example `example.com/my-app`, the prefix part needs to adhere to [RFC 1123](https://datatracker.ietf.org/doc/html/rfc1123) DNS subdomain restrictions and be a maximum of 253 characters."), "value": z.string().regex(new RegExp("^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?")).min(0).max(63).describe("The Kubernetes taint value.\n\n- A key can contain alphanumeric characters, dashes (`-`), underscores (`_`), or dots (`.`). Start and end it with an alphanumeric character.\n\n- Can be specified as an empty string value with `\"\"`.") }).strict()).min(0).describe("Kubernetes taints to add to node pool nodes. Taints help control how pods are scheduled onto nodes, specifically allowing them to repel certain pods. To learn more, review [Add labels and taints to your LKE node pools](https://www.linode.com/docs/products/compute/kubernetes/guides/deploy-and-manage-cluster-with-the-linode-api/#add-labels-and-taints-to-your-lke-node-pools).\n\nSpecifying an empty array (`[]`) removes all previously set taints.").optional(), "type": z.string().describe("The Linode Type for all of the nodes in the Node Pool.") }).strict().describe("Specifies a collection of Linodes to serve as members of a Kubernetes cluster.")),
  "region": z.string().describe("__Filterable__ This Kubernetes cluster's location."),
  "tags": z.array(z.string()).describe("__Filterable__ An array of tags applied to the Kubernetes cluster. Tags are for organizational purposes only.").optional(),
  "tier": z.enum(["standard","enterprise"]).describe("__Beta__, __Filterable__ The desired Kubernetes tier, either `standard` or `enterprise`.\n\n> 🚧\n>\n> This field is in beta and only works when using the beta API. Call the URL with the `apiVersion` path parameter set to `v4beta`.").optional()
}